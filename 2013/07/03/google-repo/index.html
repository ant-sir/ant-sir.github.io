<!DOCTYPE html>
<html lang="zh-cn">
<head prefix="og: https://ogp.me/ns#"><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>Google Repo | Ant-Home</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://ant-sir.xyz/2013/07/03/google-repo/index.html">
  
  <!-- Alternative links -->
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/icon/mstile-144x144.png">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  <link rel="stylesheet" href="/css/navy.css">
  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css">
  <!-- Google Analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61377615-1', 'auto');
  ga('send', 'pageview');
</script>

  <!-- Baidu auto push -->
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/" id="logo">Hexo</a>
    </h1>
    <nav id="main-nav">
      <a href="/" class="main-nav-link">主页</a><a href="/categories/" class="main-nav-link">分类</a><a href="/archives/" class="main-nav-link">归档</a><a href="/about/" class="main-nav-link">关于</a>
      <a href="https://github.com/ant-sir/site" class="main-nav-link"><i class="fa fa-github-alt"></i></a>
      <div id="search-input-wrap">
        <div id="search-input-icon">
          <i class="fa fa-search"></i>
        </div>
        <input type="search" id="search-input" placeholder="Search...">
      </div>
    </nav>
    <div id="lang-select-wrap">
      <label id="lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></label>
      <select id="lang-select" data-canonical="">
        
          <option value="zh-cn" selected>简体中文</option>
        
      </select>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="https://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">Google Repo</h1>
                <a href="https://github.com/ant-sir/site/edit/master/source/_posts/2013-07-03-google-repo.md" class="article-edit-link" title="改进本文"><i class="fa fa-pencil"></i></a>
              </header>
              <div class="article-content" itemprop="articleBody">
                <p>repo是Google用来管理Android源代码的工具。<br><a id="more"></a></p>
<h1 id="从Android说起" class="article-heading"><a href="#从Android说起" class="headerlink" title="从Android说起"></a>从Android说起<a class="article-anchor" href="#从Android说起" aria-hidden="true"></a></h1><p><a href="https://source.android.com/" target="_blank" rel="noopener">Android</a>的所有源代码都放在<a href="https://source.android.com/source/using-repo" target="_blank" rel="noopener">Google</a>的Git仓库中。需要使用<a href="https://source.android.com/source/using-repo" target="_blank" rel="noopener">Google</a>开发的Repo工具进行下载管理。</p>
<h2 id="AOSP的组成" class="article-heading"><a href="#AOSP的组成" class="headerlink" title="AOSP的组成"></a>AOSP的组成<a class="article-anchor" href="#AOSP的组成" aria-hidden="true"></a></h2><p>AOSP(<a href="https://source.android.com/" target="_blank" rel="noopener">Android</a>项目库)最主要由三种类型的仓库组成，repo库，manifest库，android项目子库。</p>
<p><code>repo</code>库提供Repo工具的实现脚本，<code>manifest</code>库里面的xml清单文件描述了<a href="https://source.android.com/" target="_blank" rel="noopener">Android</a>所有项目库的信息，Repo工具使用<code>manifest</code>库的描述文件管理各种Git库。<a href="https://source.android.com/" target="_blank" rel="noopener">Android</a>子项目库即为实际构成<a href="https://source.android.com/" target="_blank" rel="noopener">Android</a>项目的Git库。</p>
<p>获取<a href="https://source.android.com/" target="_blank" rel="noopener">Android</a>项目时，最初使用curl获取repo的启动文件。该文件并非完整的repo库，只是一个获取完整repo库的前导文件。</p>
<h2 id="repo库" class="article-heading"><a href="#repo库" class="headerlink" title="repo库"></a>repo库<a class="article-anchor" href="#repo库" aria-hidden="true"></a></h2><p><code>repo</code>库不仅提供了Repo引导文件，还包含完整的Repo工具源代码。该源码库即是AOSP的管理工具，又是AOSP库的一部分，并具有自管理能力。</p>
<h2 id="manifest库" class="article-heading"><a href="#manifest库" class="headerlink" title="manifest库"></a>manifest库<a class="article-anchor" href="#manifest库" aria-hidden="true"></a></h2><p><code>manifest</code>库是在<code>repo init</code>命令初始化项目时下载下来的，里面的XML清单文件定义了整个AOSP包含的项目以及所有的管理信息。在使用repo引导脚本进行初始化的时候，必须通过<code>-u</code>参数指定清单库的地址。</p>
<p>当执行完毕<code>repo init</code>之后，工作目录内只有一个.repo目录。在该目录下除了<code>repo</code>库外，就是manifest库，以及一个链接到manifest库中清单库中的default.xml符号链接。该库管理着实际的所有AOSP项目库。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">总用量 24</span><br><span class="line">drwxrwxr-x.  3 zyl zyl 4096 4月  22 23:52 manifests</span><br><span class="line">drwxrwxr-x. 10 zyl zyl 4096 4月  23 00:01 manifests.git</span><br><span class="line">lrwxrwxrwx.  1 zyl zyl   21 4月  22 23:52 manifest.xml -&gt; manifests/default.xml</span><br><span class="line">drwxrwxr-x.  7 zyl zyl 4096 4月  23 00:01 repo</span><br></pre></td></tr></table></figure></p>
<p>打开清单文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"aosp"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">fetch</span>=<span class="string">".."</span></span></span><br><span class="line"><span class="tag">           <span class="attr">review</span>=<span class="string">"https://android-review.googlesource.com/"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default</span> <span class="attr">revision</span>=<span class="string">"master"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">remote</span>=<span class="string">"aosp"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">sync-j</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">path</span>=<span class="string">"build/make"</span> <span class="attr">name</span>=<span class="string">"platform/build"</span> <span class="attr">groups</span>=<span class="string">"pdk"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">copyfile</span> <span class="attr">src</span>=<span class="string">"core/root.mk"</span> <span class="attr">dest</span>=<span class="string">"Makefile"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linkfile</span> <span class="attr">src</span>=<span class="string">"CleanSpec.mk"</span> <span class="attr">dest</span>=<span class="string">"build/CleanSpec.mk"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linkfile</span> <span class="attr">src</span>=<span class="string">"buildspec.mk.default"</span> <span class="attr">dest</span>=<span class="string">"build/buildspec.mk.default"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linkfile</span> <span class="attr">src</span>=<span class="string">"core"</span> <span class="attr">dest</span>=<span class="string">"build/core"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linkfile</span> <span class="attr">src</span>=<span class="string">"envsetup.sh"</span> <span class="attr">dest</span>=<span class="string">"build/envsetup.sh"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linkfile</span> <span class="attr">src</span>=<span class="string">"target"</span> <span class="attr">dest</span>=<span class="string">"build/target"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">linkfile</span> <span class="attr">src</span>=<span class="string">"tools"</span> <span class="attr">dest</span>=<span class="string">"build/tools"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>remote</code>：定义一个远程仓库，通过该属性指定远程仓库的名称、地址和review的址。可以定义多个<code>remote</code>元素，但不能重复定义。</li>
<li><code>default</code>：定义默认的分支、远程仓库和同步线程数。只能有一个<code>default</code>元素。</li>
<li><code>project</code>：定义一个项目。<code>path</code>指定本址存放路径，<code>name</code>指定仓库的相对地址，<code>groups</code>指定所属组。不能出现重复的<code>project</code>定义（<code>name</code>属性不能相同），但是可以通过<code>remove-project</code>元素将缺省清单中定义的<code>project</code>删除再重新定义。</li>
<li><code>copyfile</code>：定义一个文件拷贝的动作。</li>
<li><code>linkfile</code>：定义一个文件链接的动作。</li>
</ul>
<p>关于<code>manfests</code>文件的详细信息可以看<code>manfests</code>的<a href="https://github.com/ant-sir/git-repo/blob/master/docs/manifest-format.txt" target="_blank" rel="noopener">文档</a>。</p>
<p>Repo支持通过本地清单，对缺省的清单文件进行补充以及覆盖。可以在<code>.repo</code>目录下创建<code>local_manifest.xml</code>文件，在Repo工具读取清单信息时其内容会和<code>.repo/manifest.xml</code>文件的内容进行合并。可以在本地的<code>local_manifest.xml</code>中使用<code>remove-project</code>元素对某个或某些项目取反。这样在<code>repo sync</code>时就不会同步或删除本地的项目目录。</p>
<h2 id="安装Repo" class="article-heading"><a href="#安装Repo" class="headerlink" title="安装Repo"></a>安装Repo<a class="article-anchor" href="#安装Repo" aria-hidden="true"></a></h2><p>Repo是一个Python开发的工具，底层使用Git操作，使用Repo可以使工作更简单。更多的信息请看<a href="/repo-about.html">Repo分析</a>章节。<br>安装Repo：</p>
<ol>
<li><p>首先确保一个本的的目录如~/.bin在环境变量当中。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/.bin</span><br><span class="line">$ PATH=~/.bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载Repo工具到上面创建的目录当中。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$curl</span> https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/.bin/repo</span><br><span class="line"><span class="variable">$chmod</span> a+x ~/.bin/repo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="初始化Repo客户端" class="article-heading"><a href="#初始化Repo客户端" class="headerlink" title="初始化Repo客户端"></a>初始化Repo客户端<a class="article-anchor" href="#初始化Repo客户端" aria-hidden="true"></a></h2><p>安装Repo后，需要设置你的本地目录以便访问Android源码仓库。</p>
<ol>
<li><p>创建一个新的空目录作为Android项目的工作目录。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir WORKING_DIRECTORY</span><br><span class="line">$ <span class="built_in">cd</span> WORKING_DIRECTORY</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置你的Git的用户名和邮件地址，如果你需要使用Gerrit的code-review功能，你需要设置你的邮件地址为你的Google account的邮件地址。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"you@example.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>repo init</code>命令来下载完整的Repo仓库。必须指定manifest仓库的URL，它提供了那些你需要获取到本地目录的仓库的信息。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest</span><br></pre></td></tr></table></figure>
<p> 你也可以指定具体的分支，使用<code>-b</code>参数指定具体要获取哪个分支。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure>
<p> 成功初始化之后你的目录里面只有一个.repo的目录，该目录下有：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">总用量 24</span><br><span class="line">drwxrwxr-x.  3 zyl zyl 4096 4月  22 23:52 manifests</span><br><span class="line">drwxrwxr-x. 10 zyl zyl 4096 4月  23 00:01 manifests.git</span><br><span class="line">lrwxrwxrwx.  1 zyl zyl   21 4月  22 23:52 manifest.xml -&gt; manifests/default.xml</span><br><span class="line">drwxrwxr-x.  7 zyl zyl 4096 4月  23 00:01 repo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="下载Android源码树" class="article-heading"><a href="#下载Android源码树" class="headerlink" title="下载Android源码树"></a>下载Android源码树<a class="article-anchor" href="#下载Android源码树" aria-hidden="true"></a></h2><p>跟据默认的manifest文件拉取源代码树到你的工作目录。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repo sync</span><br></pre></td></tr></table></figure></p>
<p>这样Android源码就会以项目的名子为目录位于你的工作目录下面。</p>
<h2 id="网络问题" class="article-heading"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题<a class="article-anchor" href="#网络问题" aria-hidden="true"></a></h2><p>如果你需要通过代理来下载源码，你需要提供以下环境变更给Repo。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> HTTP_PROXY=http://&lt;proxy_user_id&gt;:&lt;proxy_password&gt;@&lt;proxy_server&gt;:&lt;proxy_port&gt;</span><br><span class="line">$ <span class="built_in">export</span> HTTPS_PROXY=https://&lt;proxy_user_id&gt;:&lt;proxy_password&gt;@&lt;proxy_server&gt;:&lt;proxy_port&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="制作地本镜像库" class="article-heading"><a href="#制作地本镜像库" class="headerlink" title="制作地本镜像库"></a>制作地本镜像库<a class="article-anchor" href="#制作地本镜像库" aria-hidden="true"></a></h2><p>当你有多个客户端都需要拉取源代码时很容易遇到带宽问题，因些做一个本地的镜像是很有必要的。下面把/usr/local/aosp/mirror目录做为镜像目录。在该目录下面初始化和同步。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /usr/<span class="built_in">local</span>/aosp/mirror</span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/aosp/mirror</span><br><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest --mirror</span><br><span class="line">$ repo sync</span><br></pre></td></tr></table></figure></p>
<blockquote class="note tip"><strong class="note-title">注意</strong><p><code>--mirror</code>参数只能在初始化一个新的仓库时使用一次，在已初始化的仓库下再次使用会报错。</p>
</blockquote>
<p>一旦同步完成，新的客户端就可以从这个镜像拉取。该镜像需要再次同步以保持与上游镜像同步，客户端也需要再次同步以保持最新。</p>
<h2 id="校验Git-Tags" class="article-heading"><a href="#校验Git-Tags" class="headerlink" title="校验Git Tags"></a>校验Git Tags<a class="article-anchor" href="#校验Git-Tags" aria-hidden="true"></a></h2><p>加载以下公钥到你的GnuPG key数据库中，这个公钥用以签名那些未发行的标签。Repo默认只使用已稳定发布的版本（可以使用<code>git tag</code>查看已发行版本），除非使用<code>--no-repo-verify</code>参数指明不校验签名，才可以使用Repo库的任一分支。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --import</span><br></pre></td></tr></table></figure></p>
<p>拷贝并粘贴以下key到你的终端，以EOF(CTRL-D)结尾。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">Version: GnuPG v1.4.2.2 (GNU/Linux)</span><br><span class="line"></span><br><span class="line">mQGiBEnnWD4RBACt9/h4v9xnnGDou13y3dvOx6/t43LPPIxeJ8eX9WB+8LLuROSV</span><br><span class="line">lFhpHawsVAcFlmi7f7jdSRF+OvtZL9ShPKdLfwBJMNkU66/TZmPewS4m782ndtw7</span><br><span class="line">8tR1cXb197Ob8kOfQB3A9yk2XZ4ei4ZC3i6wVdqHLRxABdncwu5hOF9KXwCgkxMD</span><br><span class="line">u4PVgChaAJzTYJ1EG+UYBIUEAJmfearb0qRAN7dEoff0FeXsEaUA6U90sEoVks0Z</span><br><span class="line">wNj96SA8BL+a1OoEUUfpMhiHyLuQSftxisJxTh+2QclzDviDyaTrkANjdYY7p2cq</span><br><span class="line">/HMdOY7LJlHaqtXmZxXjjtw5Uc2QG8UY8aziU3IE9nTjSwCXeJnuyvoizl9/I1S5</span><br><span class="line">jU5SA/9WwIps4SC84ielIXiGWEqq6i6/sk4I9q1YemZF2XVVKnmI1F4iCMtNKsR4</span><br><span class="line">MGSa1gA8s4iQbsKNWPgp7M3a51JCVCu6l/8zTpA+uUGapw4tWCp4o0dpIvDPBEa9</span><br><span class="line">b/aF/ygcR8mh5hgUfpF9IpXdknOsbKCvM9lSSfRciETykZc4wrRCVGhlIEFuZHJv</span><br><span class="line">aWQgT3BlbiBTb3VyY2UgUHJvamVjdCA8aW5pdGlhbC1jb250cmlidXRpb25AYW5k</span><br><span class="line">cm9pZC5jb20+iGAEExECACAFAknnWD4CGwMGCwkIBwMCBBUCCAMEFgIDAQIeAQIX</span><br><span class="line">gAAKCRDorT+BmrEOeNr+AJ42Xy6tEW7r3KzrJxnRX8mij9z8tgCdFfQYiHpYngkI</span><br><span class="line">2t09Ed+9Bm4gmEO5Ag0ESedYRBAIAKVW1JcMBWvV/0Bo9WiByJ9WJ5swMN36/vAl</span><br><span class="line">QN4mWRhfzDOk/Rosdb0csAO/l8Kz0gKQPOfObtyYjvI8JMC3rmi+LIvSUT9806Up</span><br><span class="line">hisyEmmHv6U8gUb/xHLIanXGxwhYzjgeuAXVCsv+EvoPIHbY4L/KvP5x+oCJIDbk</span><br><span class="line">C2b1TvVk9PryzmE4BPIQL/NtgR1oLWm/uWR9zRUFtBnE411aMAN3qnAHBBMZzKMX</span><br><span class="line">LWBGWE0znfRrnczI5p49i2YZJAjyX1P2WzmScK49CV82dzLo71MnrF6fj+Udtb5+</span><br><span class="line">OgTg7Cow+8PRaTkJEW5Y2JIZpnRUq0CYxAmHYX79EMKHDSThf/8AAwUIAJPWsB/M</span><br><span class="line">pK+KMs/s3r6nJrnYLTfdZhtmQXimpoDMJg1zxmL8UfNUKiQZ6esoAWtDgpqt7Y7s</span><br><span class="line">KZ8laHRARonte394hidZzM5nb6hQvpPjt2OlPRsyqVxw4c/KsjADtAuKW9/d8phb</span><br><span class="line">N8bTyOJo856qg4oOEzKG9eeF7oaZTYBy33BTL0408sEBxiMior6b8LrZrAhkqDjA</span><br><span class="line">vUXRwm/fFKgpsOysxC6xi553CxBUCH2omNV6Ka1LNMwzSp9ILz8jEGqmUtkBszwo</span><br><span class="line">G1S8fXgE0Lq3cdDM/GJ4QXP/p6LiwNF99faDMTV3+2SAOGvytOX6KjKVzKOSsfJQ</span><br><span class="line">hN0DlsIw8hqJc0WISQQYEQIACQUCSedYRAIbDAAKCRDorT+BmrEOeCUOAJ9qmR0l</span><br><span class="line">EXzeoxcdoafxqf6gZlJZlACgkWF7wi2YLW3Oa+jv2QSTlrx4KLM=</span><br><span class="line">=Wi5D</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure></p>
<p>导入key之后就可以校验和打标签<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -v TAG_NAME</span><br></pre></td></tr></table></figure></p>
<h1 id="REPO的使用" class="article-heading"><a href="#REPO的使用" class="headerlink" title="REPO的使用"></a>REPO的使用<a class="article-anchor" href="#REPO的使用" aria-hidden="true"></a></h1><p>Repo的命令有如下格式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo &lt;COMMAND&gt; &lt;OPTIONS&gt;</span><br></pre></td></tr></table></figure></p>
<p>带[ ]的是可选参数。例如，很多的命令需要一个项目列表做为参数，你可以提供项目的名字列表或项目的相对路径列表：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo sync [&lt;PROJECT0&gt; &lt;PROJECT1&gt; ... &lt;PROJECTN&gt;]</span><br><span class="line">repo sync [&lt;/PATH/TO/PROJECT0&gt; ... &lt;/PATH/TO/PROJECTN&gt;]</span><br></pre></td></tr></table></figure></p>
<h2 id="help" class="article-heading"><a href="#help" class="headerlink" title="help"></a>help<a class="article-anchor" href="#help" aria-hidden="true"></a></h2><p>一旦你安装了Repo，你可以通过以下命令查找最新的带所有命令预览的文档。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p>你可以指定具体命令以获取更详细的信息。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">help</span> &lt;COMMAND&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如，以下命令会列出init命令的描述和参数列表。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">help</span> init</span><br></pre></td></tr></table></figure></p>
<h2 id="init" class="article-heading"><a href="#init" class="headerlink" title="init"></a>init<a class="article-anchor" href="#init" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u &lt;URL&gt; [&lt;OPTIONS&gt;]</span><br></pre></td></tr></table></figure>
<p>安装Repo到当前目录。该命令会创建一个<code>.repo/</code>目录，它包含Repo的完整Git仓库和标准Android manifest文件。<code>.repo/</code>目录下也会包含一个<code>manifest.xml</code>文件，它是<code>.repo/manifest/</code>目录下选定manifest文件的符号链接。</p>
<p>选项：</p>
<ul>
<li><code>-u | --manifest-url=URL</code>: 指定manifest仓库的URL。</li>
<li><code>-m | --manifest-name=NAME.xml</code>: 指定使用哪个xml文件，manifest仓库里面可以有多个管理仓库的xml文件，如果不指定默认使用default.xml。</li>
<li><code>-b | --manifest-branch=REVISION</code>: 指定所使用的manifest仓库的哪个分支</li>
<li><code>--mirror</code>: 指定以建立和上游Android的版本库一模一样的镜像。</li>
<li><code>--no-clone-bundle</code>: 指定在克隆仓库时不使用bundle文件。bundle文件是一种库的压缩文件，可以提高库的下载效率。可以查看<code>git bundle</code>了解更多。</li>
<li><code>--repo-url=URL</code>: 指定repo仓库的地址，如果不指定，则使用repo文件内指定的地址。</li>
<li><code>--repo-branch=REVISION</code>: 指定要使用的repo仓库的分支，如果不指定，则使用repo文件内指定的stable。</li>
<li><code>--no-repo-verify</code>: 指定不校验repo仓库的签名，Repo默认使用已签名的发行版本（即打了tag的），如果想使用最新的（未签名）的版本，则必须使用该参数。如果不指定该参数，默认会忽略stable分支，使用最新的发行版本。</li>
</ul>
<blockquote class="note tip"><strong class="note-title">注意</strong><p>除<code>init</code>外的其它命令都需要在工作目录（即<code>.repo/</code>的父目录）或其子目录下执行。</p>
</blockquote>
<h2 id="sync" class="article-heading"><a href="#sync" class="headerlink" title="sync"></a>sync<a class="article-anchor" href="#sync" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo sync [&lt;PROJECT_LIST&gt;]</span><br></pre></td></tr></table></figure>
<p>下载最新的变更并更新本地工作区文件。如果运行<code>repo sync</code>不带任何参数它将同步所有项目。</p>
<p>当你运行<code>repo sync</code>时，发生了什么：</p>
<ul>
<li>如果你的项目从来没有被同步过，<code>repo sync</code>等同于<code>git clone</code>。所有在远程仓库分支都会被克隆到本地。</li>
<li><p>如果你的项目已经同步过了，<code>repo sync</code>等同于以下两条命令：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote update</span><br><span class="line">git rebase origin/&lt;BRANCH&gt;</span><br></pre></td></tr></table></figure>
<p>  上面的<code>&lt;BRANCH&gt;</code>为当前已经检出的分支。如果本地分支没有跟踪任何的远程分支，则<code>rebase</code>不会进行。</p>
</li>
<li>如查<code>git rebase</code>操作冲突了，你需要使用Git命令来处理冲突。</li>
</ul>
<p>成功执行<code>repo sync</code>命令后，命令行指定的或所有的项目都和远程仓库保持一致。</p>
<p>选项：</p>
<ul>
<li><code>-d</code>: 将指定的项目切换回manifest文件指定的分支，如果项目当前处于特性分支上，这是非常有用的。</li>
<li><code>-s</code>: 同步到一个在清单文件中指明的已知的编译编译成功版本。</li>
<li><code>-f</code>: 继续同步其他项目即使有的项目同步失败。</li>
</ul>
<h2 id="start" class="article-heading"><a href="#start" class="headerlink" title="start"></a>start<a class="article-anchor" href="#start" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo start &lt;BRANCH_NAME&gt; [--all | &lt;PROJECT_LIST&gt;]</span><br></pre></td></tr></table></figure>
<p>对于指定或所有(指定<code>--all</code>时)项目，如果清单文件中项目存在<code>dest_branch</code>属性，则使用<code>dest_branch</code>属性作为默认的merge分支（即远程跟踪分支），否则使用清单文件中默认的<code>revision</code>作为远程跟踪分支。</p>
<h2 id="status" class="article-heading"><a href="#status" class="headerlink" title="status"></a>status<a class="article-anchor" href="#status" aria-hidden="true"></a></h2><p>对指定的项目比较工作区(working tree)、暂存区(index)和最近一次提交(HEAD)。针对每个文件对于三者中任意两者有不同的显示一个概览。</p>
<p>如果只是想看当前分支的三方比较，可以远行<code>repo status .</code>。</p>
<p>该命令实际上是对git diff-index、git diff-files命令的封装，同时显示暂存区的状态和本地文件修改的状态。</p>
<ul>
<li>每个小节的首行显示项目名称，以及所在分支名称。</li>
<li>之后显示该项目中文件变更状态。头两个字母显示变更状态，后面显示文件名或者其他变更信息。</li>
<li>第一个字母表示暂存区的文件修改状态。<br>  其实是<code>git-diff-index</code>命令输出中的状态标识，并用大写显示。</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td>没有改变</td>
<td>没有改变</td>
</tr>
<tr>
<td><code>A</code></td>
<td>添加</td>
<td>不在HEAD中，在暂存区</td>
</tr>
<tr>
<td><code>M</code></td>
<td>修改</td>
<td>在HEAD中，在暂存区，内容不同</td>
</tr>
<tr>
<td><code>R</code></td>
<td>重命名</td>
<td>不在HEAD中，在暂存区，路径修改</td>
</tr>
<tr>
<td><code>C</code></td>
<td>拷贝</td>
<td>不在HEAD中，在暂存区，从其他文件拷贝</td>
</tr>
<tr>
<td><code>T</code></td>
<td>状态改变</td>
<td>在HEAD中，在暂存区，内容相同</td>
</tr>
<tr>
<td><code>U</code></td>
<td>未合并</td>
<td>需要冲突解决</td>
</tr>
<tr>
<td><code>D</code></td>
<td>删除</td>
<td>在HEAD中，不在暂存区</td>
</tr>
</tbody>
</table>
<ul>
<li>第二个字母表示工作区文件的更改状态。<br>  其实是<code>git-diff-files</code>命令输出中的状态标识，并用小写显示。</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-</code></td>
<td>新/未知</td>
<td>不在暂存区，在工作区</td>
</tr>
<tr>
<td><code>m</code></td>
<td>修改</td>
<td>在暂存区，在工作区，被修改</td>
</tr>
<tr>
<td><code>d</code></td>
<td>删除</td>
<td>在暂存区，不在工作区</td>
</tr>
</tbody>
</table>
<ul>
<li>两个表示状态的字母后面，显示文件名信息。如果有文件重命名还会显示改变前后的文件名以及文件的相似度。</li>
</ul>
<h2 id="checkout" class="article-heading"><a href="#checkout" class="headerlink" title="checkout"></a>checkout<a class="article-anchor" href="#checkout" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo checkout &lt;branchname&gt; [&lt;project&gt;...]</span><br></pre></td></tr></table></figure>
<p><code>checkout</code>命令实际上是对<code>git checkout</code>命令的封装。检出之前由<code>repo start</code>创建的分支。</p>
<h2 id="branches" class="article-heading"><a href="#branches" class="headerlink" title="branches"></a>branches<a class="article-anchor" href="#branches" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo branches [&lt;project&gt;...]</span><br></pre></td></tr></table></figure>
<blockquote class="note tip"><strong class="note-title">注意</strong><p>是<code>branches</code>而不是Git的命令<code>branch</code>。</p>
</blockquote>
<p>读取各个项目的分支列表并汇总显示。该命令实际上是通过直接读取.git/refs目录下的引用来获取分支列表，以及分支的发布状态等。</p>
<p>输出格式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   develop                   | <span class="keyword">in</span> site</span><br><span class="line">*P master                    | <span class="keyword">in</span> site</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个字段显示分支的状态：是否是当前分支，分支是否已发布到代码审核服务器上。<ul>
<li>第一个字母若显示星号(*)，含义是此分支为当前分支。</li>
<li>第二个字母若为大写字母P，则含义是分支所有提交都发布到代码审核服务器上了。第二个字母若为小写字母p，则含义是只有部分提交被发布到代码审核服务器上。若不显示P或者p，则表明分支尚未发布。</li>
</ul>
</li>
<li>第二个字段为分支名。</li>
<li>第三个字段为以竖线（|）开始的字符串，表示该分支存在于哪些项目中。<ul>
<li><code>| in all projects</code>: 该分支处于所有项目中。</li>
<li><code>| in project1 project2</code>: 该分支只在特定项目中定义。如：project1、project2。</li>
<li><code>| not in project1</code>: 该分支不存在于这些项目中。即除了project1项目外，其他项目都包含此分支。</li>
</ul>
</li>
</ul>
<h2 id="diff" class="article-heading"><a href="#diff" class="headerlink" title="diff"></a>diff<a class="article-anchor" href="#diff" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo diff [&lt;PROJECT_LIST&gt;]</span><br></pre></td></tr></table></figure>
<p>实际上是对git diff命令的封装，用以分别显示各个项目工作区下的文件差异。</p>
<h2 id="stage" class="article-heading"><a href="#stage" class="headerlink" title="stage"></a>stage<a class="article-anchor" href="#stage" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo stage -i [&lt;project&gt;...]</span><br></pre></td></tr></table></figure>
<p><code>repo stage</code>命令实际上是对<code>git add –interactive</code>命令的封装，用以对各个项目工作区中的改动（修改、添加等）进行挑选以加入暂存区。</p>
<h2 id="upload" class="article-heading"><a href="#upload" class="headerlink" title="upload"></a>upload<a class="article-anchor" href="#upload" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo upload [--re --cc] &#123;[&lt;PROJECT&gt;]... | --replace &lt;PROJECT&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>针对指定项目，Repo比较上次同步之后的本地分支与远程分支，Repo会提示你选择一个或多个分支你还没有<code>upload</code>的分支去review。</p>
<p>当你选择了一个或多个分支后，所有在所选分支的新的变更被通过HTTP的方式传输到Gerrit，你需要配置好你的Gerrit传输方式。为了减少Review的次数，在<code>upload</code>之前你需要尽量合并你的相同特性的提交以便review可以一次通过。</p>
<p>如果你运行<code>repo upload</code>时没有带任何参数，Repo会查找所有项目的所有变更去<code>upload</code>。</p>
<p>选项：</p>
<ul>
<li><code>-h, --help</code>: 显示帮助信息。</li>
<li><code>-t</code>: 发送本地分支名称到Gerrit代码审核服务器。</li>
<li><code>--replace</code>: 发送此分支的更新补丁集。注意使用该参数，只能指定一个项目。</li>
<li><code>--re=REVIEWERS, --reviewers=REVIEWERS</code>: 要求由指定的人员进行审核。</li>
<li><code>--cc=CC</code>: 同时发送通知到如下邮件地址。</li>
</ul>
<p>当已经通过<code>repo upload</code>命令在代码审查服务器上提交了一个修订集，会得到一个修订号(Review-Id)。关于此次修订的相关讨论会发送到提交者的邮箱中。如果修订集有误没有通过审核，可以重新修改代码，再次向代码审核服务器上传修订集。</p>
<p>一个修订集修改后再次上传，确保修订集的ID不变是非常有用的，因为这样相关的修订集都在代码审核服务器的同一个界面中显示。</p>
<p>在执行<code>repo upload</code>时会弹出一个编辑界面，提示在方括号中输入修订集编号，否则会在代码审查服务器上创建新的ID。有两个办法可以不用手工输入修订集，一个是使用<code>git commit --amend</code>做一个修补提交，或者使用如下方法加一个<code>--replace</code>参数，如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo upload --replace &lt;PROJECT_NAME&gt;</span><br></pre></td></tr></table></figure></p>
<p>当使用<code>--replace</code>参数后，Repo会检查本地版本库名为<code>refs/published/&lt;PROJECT_NAME&gt;</code>的特殊引用（上一次提交的修订），获得其对应的提交SHA1哈希值。然后在本地代码审核服务器对应的<code>refs/changes/</code>命名空间下的特殊引用中寻找和提交SHA1哈希值匹配的引用，找到匹配的引用，其名称中就包含有变更集ID，直接用此变更集ID作为新的变更集ID提交到代码审核服务器。</p>
<h2 id="download" class="article-heading"><a href="#download" class="headerlink" title="download"></a>download<a class="article-anchor" href="#download" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo download &lt;TARGET&gt; &lt;CHANGE&gt;</span><br></pre></td></tr></table></figure>
<p>从Gerrit的代码审核系统下载特定的变更到本地工作区并切换到对应的变更上。<br>举个例子，如果你收到邮件有一个<code>platform/build</code>项目的<code>change 23823</code>的变更需要review，你需要下载23823到你的<code>platform/build</code>目录上：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo download platform/build 23823</span><br></pre></td></tr></table></figure></p>
<p>命令<code>repo sync</code>会清除任何的你使用<code>repo download</code>命令下载到本地工作区的提交。</p>
<h2 id="rebase" class="article-heading"><a href="#rebase" class="headerlink" title="rebase"></a>rebase<a class="article-anchor" href="#rebase" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo rebase &#123;[&lt;PROJECT&gt;...] | -i &lt;PROJECT&gt;...&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是对git rebase命令的封装，该命令的参数也作为git rebase命令的参数。但 -i 参数仅当对一个项执行时有效。</p>
<h2 id="prune" class="article-heading"><a href="#prune" class="headerlink" title="prune"></a>prune<a class="article-anchor" href="#prune" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo prune [&lt;PROJECT&gt;...]</span><br></pre></td></tr></table></figure>
<p>实际上是对git branch -d命令的封装，该命令用于扫描项目的各个分支，并删除已经合并的分支。</p>
<h2 id="abandon" class="article-heading"><a href="#abandon" class="headerlink" title="abandon"></a>abandon<a class="article-anchor" href="#abandon" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo abandon &lt;BRANCH_NAME&gt; [&lt;PROJECT&gt;...]</span><br></pre></td></tr></table></figure>
<p>相比repo prune命令，repo abandon命令更具破坏性，因为repo abandon是对git branch -D命令的封装。该命令非常危险，直接删除分支，请慎用。</p>
<h2 id="forall" class="article-heading"><a href="#forall" class="headerlink" title="forall"></a>forall<a class="article-anchor" href="#forall" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo forall [&lt;PROJECT_LIST&gt;] -c &lt;COMMAND&gt;</span><br></pre></td></tr></table></figure>
<p>针对每一个项目执行给定的shell命令。有以下环境变量在<command>中是有效的：</p>
<ul>
<li><code>REPO_PROJECT</code>: 是项目名字的唯一序列</li>
<li><code>REPO_PATH</code>： 项目相对根的路径</li>
<li><code>REPO_REMOTE</code>： 清单文件指定的远程仓库名字</li>
<li><code>REPO_LREV</code>： 本地远程跟踪分支的名字</li>
<li><code>REPO_RREV</code>： 清单文件中指定的远程分支的名字</li>
</ul>
<p>选项：</p>
<ul>
<li><code>-c</code>： 执行后面指定的命令通过<code>/bin/sh</code>。</li>
<li><code>-p</code>： 在指定命令输出前显示项目头信息。</li>
<li><code>-v</code>： 显示错误信息。</li>
</ul>
<h2 id="version" class="article-heading"><a href="#version" class="headerlink" title="version"></a>version<a class="article-anchor" href="#version" aria-hidden="true"></a></h2><p>显示repo的版本号。</p>
<h2 id="list" class="article-heading"><a href="#list" class="headerlink" title="list"></a>list<a class="article-anchor" href="#list" aria-hidden="true"></a></h2><p>列出所有项目与库的对应列表</p>
<h2 id="selfupdate" class="article-heading"><a href="#selfupdate" class="headerlink" title="selfupdate"></a>selfupdate<a class="article-anchor" href="#selfupdate" aria-hidden="true"></a></h2><p>用于repo自身的更新。如果提供<code>--repo-upgraded</code>参数，还会更新各个项目的钩子脚本。</p>
<h2 id="manifest" class="article-heading"><a href="#manifest" class="headerlink" title="manifest"></a>manifest<a class="article-anchor" href="#manifest" aria-hidden="true"></a></h2><p>显示manifest文件内容。</p>
<h2 id="官网的cheatsheet" class="article-heading"><a href="#官网的cheatsheet" class="headerlink" title="官网的cheatsheet"></a>官网的cheatsheet<a class="article-anchor" href="#官网的cheatsheet" aria-hidden="true"></a></h2><p><img src="/img/git-repo-useages.png" alt="git-repo-useages"></p>
<h2 id="Repo工作流" class="article-heading"><a href="#Repo工作流" class="headerlink" title="Repo工作流"></a>Repo工作流<a class="article-anchor" href="#Repo工作流" aria-hidden="true"></a></h2><p><img src="/img/repo-workflow.png" alt="repo-workflow"></p>
<h1 id="REPO的引导文件" class="article-heading"><a href="#REPO的引导文件" class="headerlink" title="REPO的引导文件"></a>REPO的引导文件<a class="article-anchor" href="#REPO的引导文件" aria-hidden="true"></a></h1><p>前面提到通过<code>curl</code>下载的Repo文件仅仅是一个引导脚本（bootstrap），Repo引导脚本的主要工作：</p>
<ul>
<li>加载完整的Repo工具库到当前目录下的<code>.repo/repo</code>目录下。</li>
<li>启动并将控制权交给工作区的<code>.repo/repo/main.py</code>这个刚刚从<code>repo.git</code>库克隆来的脚本文件。</li>
<li>之后在<code>main.py</code>文件中克隆Android的清单库<code>manifest.git</code>（这已经不是引导脚本的工作了）。</li>
</ul>
<p>Repo引导文件所做的事情非常简单，如果第一次执行，下载完整的Repo仓库，之后把工作交给main.py。如果不是第一次执行，则直接把工作交给main.py去执行。</p>
<p>阅读Repo引导文件可以从中获取一些有用的信息，下面对Repo启动脚本作一个分析：</p>
<h2 id="入口" class="article-heading"><a href="#入口" class="headerlink" title="入口"></a>入口<a class="article-anchor" href="#入口" aria-hidden="true"></a></h2><p>repo脚本主入口函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p>
<p>调用main函数，参数为<code>init -u https://android.googlesource.com/platform/manifest</code></p>
<h2 id="main函数" class="article-heading"><a href="#main函数" class="headerlink" title="main函数"></a>main函数<a class="article-anchor" href="#main函数" aria-hidden="true"></a></h2><p><code>main</code>函数实现如下（删除了一些无关的信息）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(orig_args)</span>:</span></span><br><span class="line">  repo_main, rel_repo_dir = _FindRepo()</span><br><span class="line">  cmd, opt, args = _ParseArguments(orig_args)</span><br><span class="line"></span><br><span class="line">  wrapper_path = os.path.abspath(__file__)</span><br><span class="line">  my_main, my_git = _RunSelf(wrapper_path)</span><br><span class="line"></span><br><span class="line">  cwd = os.getcwd()</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> repo_main:</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'init'</span> <span class="keyword">or</span> cmd == <span class="string">'gitc-init'</span>:</span><br><span class="line">      <span class="keyword">if</span> my_git:</span><br><span class="line">        _SetDefaultsTo(my_git)</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        _Init(args, gitc_init=(cmd == <span class="string">'gitc-init'</span>))</span><br><span class="line">      <span class="keyword">except</span> CloneFailure:</span><br><span class="line">        shutil.rmtree(os.path.join(repodir, S_repo), ignore_errors=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">      repo_main, rel_repo_dir = _FindRepo()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      _NoCommands(cmd)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> my_main:</span><br><span class="line">    repo_main = my_main</span><br><span class="line"></span><br><span class="line">  ver_str = <span class="string">'.'</span>.join(map(str, VERSION))</span><br><span class="line">  me = [sys.executable, repo_main,</span><br><span class="line">        <span class="string">'--repo-dir=%s'</span> % rel_repo_dir,</span><br><span class="line">        <span class="string">'--wrapper-version=%s'</span> % ver_str,</span><br><span class="line">        <span class="string">'--wrapper-path=%s'</span> % wrapper_path,</span><br><span class="line">        <span class="string">'--'</span>]</span><br><span class="line">  me.extend(orig_args)</span><br><span class="line">  me.extend(extra_args)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    os.execv(sys.executable, me)</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    _print(<span class="string">"fatal: unable to start %s"</span> % repo_main, file=sys.stderr)</span><br><span class="line">    _print(<span class="string">"fatal: %s"</span> % e, file=sys.stderr)</span><br><span class="line">    sys.exit(<span class="number">148</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>main</code>函数首先查找完整的repo仓库是否存在（<code>_FindRepo()</code>函数），如果存在则使用<code>os.execv</code>调用<code>main.py</code>把控制权直接交给<code>main.py</code>。如果repo仓库不存在，则使用本地函数<code>_Init</code>创建目录并下载repo仓库。因为此时没有repo仓库，所以完整repo仓库的下载仅能使用Repo引导文件的内部函数，这与后续其它仓库的下载是不一样的。</p>
<h2 id="完整的Repo库" class="article-heading"><a href="#完整的Repo库" class="headerlink" title="完整的Repo库"></a>完整的Repo库<a class="article-anchor" href="#完整的Repo库" aria-hidden="true"></a></h2><p><code>_RunSelf</code>判断运行Repo脚本所在目录是否存在<code>main.py</code>和<code>.git</code>目录，如果存在就继续判断是否存在<code>git_config.py</code>，<code>project.py</code>，<code>subcmds</code>目录。从这段代码可以看出，一个完整的Repo仓库需要<code>main.py</code>，<code>.git</code>，<code>git_config.py</code>，<code>project.py</code>，<code>subcmds</code>这五部分组成。如果这些都存在，就认为本地存在完整的repo仓库。</p>
<h2 id="使用bundle文件" class="article-heading"><a href="#使用bundle文件" class="headerlink" title="使用bundle文件"></a>使用bundle文件<a class="article-anchor" href="#使用bundle文件" aria-hidden="true"></a></h2><p><code>_Init</code>函数内部使用了<code>_Clone</code>函数来克隆代码，实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Clone</span><span class="params">(url, local, quiet)</span>:</span></span><br><span class="line">  <span class="string">"""Clones a git repository to a new subdirectory of repodir</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    os.mkdir(local)</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    _print(<span class="string">'fatal: cannot make %s directory: %s'</span> % (local, e.strerror),</span><br><span class="line">           file=sys.stderr)</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br><span class="line"></span><br><span class="line">  cmd = [GIT, <span class="string">'init'</span>, <span class="string">'--quiet'</span>]</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    proc = subprocess.Popen(cmd, cwd = local)</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  _InitHttp()</span><br><span class="line">  _SetConfig(local, <span class="string">'remote.origin.url'</span>, url)</span><br><span class="line">  _SetConfig(local, <span class="string">'remote.origin.fetch'</span>,</span><br><span class="line">                    <span class="string">'+refs/heads/*:refs/remotes/origin/*'</span>)</span><br><span class="line">  <span class="keyword">if</span> _DownloadBundle(url, local, quiet):</span><br><span class="line">    _ImportBundle(local)</span><br><span class="line">  _Fetch(url, local, <span class="string">'origin'</span>, quiet)</span><br></pre></td></tr></table></figure></p>
<p>为了加速下载，Google为每个仓库都提供了对应的bundle文件，下载时Repo时会先下载repo仓库的bundle文件，如果下载成功则从bundle文件中fetch出库，无论成功与否都会再次通过<code>git fetch</code>命令获取仓库。（<code>git fetch</code>可以直接从bundle文件提取出库。）</p>
<h2 id="使用代理" class="article-heading"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理<a class="article-anchor" href="#使用代理" aria-hidden="true"></a></h2><p>从<code>_InitHttp</code>函数可以看出，repo引导脚本支持两种代理方式：</p>
<ul>
<li>用户目录下的<code>.netrc</code>文件</li>
<li>直接在终端下指定<code>http_proxy</code>环境变量</li>
</ul>
<h2 id="Repo仓库地址" class="article-heading"><a href="#Repo仓库地址" class="headerlink" title="Repo仓库地址"></a>Repo仓库地址<a class="article-anchor" href="#Repo仓库地址" aria-hidden="true"></a></h2><p>Repo仓库的地下可以通过多种方式给出，一种是通过命令行参数<code>--repo-url=URL</code>，一种是通过环境变量<code>REPO_URL</code>给出，另一种是写死在引导文件代码里。当然，对应的分支亦可以通过这几种方法指定。</p>
<h2 id="真正的checkout" class="article-heading"><a href="#真正的checkout" class="headerlink" title="真正的checkout"></a>真正的checkout<a class="article-anchor" href="#真正的checkout" aria-hidden="true"></a></h2><p><code>_Checkout</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Checkout</span><span class="params">(cwd, branch, rev, quiet)</span>:</span></span><br><span class="line">  <span class="string">"""Checkout an upstream branch into the repository and track it.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  cmd = [GIT, <span class="string">'update-ref'</span>, <span class="string">'refs/heads/default'</span>, rev]</span><br><span class="line">  <span class="keyword">if</span> subprocess.Popen(cmd, cwd = cwd).wait() != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br><span class="line"></span><br><span class="line">  _SetConfig(cwd, <span class="string">'branch.default.remote'</span>, <span class="string">'origin'</span>)</span><br><span class="line">  _SetConfig(cwd, <span class="string">'branch.default.merge'</span>, <span class="string">'refs/heads/%s'</span> % branch)</span><br><span class="line"></span><br><span class="line">  cmd = [GIT, <span class="string">'symbolic-ref'</span>, <span class="string">'HEAD'</span>, <span class="string">'refs/heads/default'</span>]</span><br><span class="line">  <span class="keyword">if</span> subprocess.Popen(cmd, cwd = cwd).wait() != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br><span class="line"></span><br><span class="line">  cmd = [GIT, <span class="string">'read-tree'</span>, <span class="string">'--reset'</span>, <span class="string">'-u'</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> quiet:</span><br><span class="line">    cmd.append(<span class="string">'-v'</span>)</span><br><span class="line">  cmd.append(<span class="string">'HEAD'</span>)</span><br><span class="line">  <span class="keyword">if</span> subprocess.Popen(cmd, cwd = cwd).wait() != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br></pre></td></tr></table></figure></p>
<p><code>_Checkout</code>函数先使用<code>git update-ref</code>把<code>refs/heads/default</code>指向为一个稳定的发布版本。然后使用<code>git symbolic-ref HEAD refs/heads/default</code>命令设置HEAD指针使其指向default分支。最后使用<code>git read-tree --reset -u HEAD</code>命令检出工作区，<code>git checkout</code>就是使用底层命令<code>read-tree</code>来实现功能的。</p>
<p>Repo仓库克隆完成之后位于工作区目标下的<code>.repo/repo</code>路径下，此时的<code>.repo</code>目标下只有Repo工具的仓库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zyl@localhost:.repo]$ ls -a</span><br><span class="line">.  ..  repo</span><br></pre></td></tr></table></figure></p>
<p>Repo仓库的分支情况如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* default</span><br><span class="line">  remotes/origin/maint</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/stable</span><br></pre></td></tr></table></figure></p>
<h2 id="调用main-py" class="article-heading"><a href="#调用main-py" class="headerlink" title="调用main.py"></a>调用main.py<a class="article-anchor" href="#调用main-py" aria-hidden="true"></a></h2><p>接下来把权限交给main.py，它会完成Repo仓库的另外一些操作以及manifests为的克隆。</p>
<h1 id="main-py" class="article-heading"><a href="#main-py" class="headerlink" title="main.py"></a>main.py<a class="article-anchor" href="#main-py" aria-hidden="true"></a></h1><p>main.py先从<code>subcmds</code>包导入<code>all_commands</code>列表，该列表由所有子命令对象组成，这些子命令在subcmds目录下，每个子命令对应一个模块文件，文件名就是子命令名，每一个文件都定义了以该文件名命令的类，该类实现了对应命令的功能。这些子命令类都是直接或间接从<code>Command</code>类继承。</p>
<p>下面来看一张子命令的类图：</p>
<p><a href="/img/class-command.png"><img src="/img/class-command.png" alt="command"></a></p>
<p>从图中可以清晰的看到子类”重载“基类的<code>Execute</code>函数以完成自己的工作。而基类的<code>Execute</code>是一个“纯虚函数”，子类必须实现。</p>
<p>Python使用如下方法达到纯虚函数的目的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">  <span class="string">"""Perform the action, after option parsing is complete.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure></p>
<p>那么main.py是如何执行命令指定命令的操作呢？main.py的主函数使用一个<code>_Repo</code>类的对象<code>repo</code>来表示Repo工具。该类主要实现了<code>_Run</code>函数，<code>_Repo</code>类对象就是用该函数来实现命令框架的。</p>
<p><code>_Run</code>函数首先根据命令行参数获取所要执行的命令名字，根据该名字从<code>all_commands</code>列表中取出对应该命令的对象。然后调用它的<code>Execute</code>函数执行子命令实现的功能。但是执行该命令所需的信息从哪里来呢（如manifest仓库在哪，仓库放置地址，用户信息等）？</p>
<p>阅读源码我们看到<code>_Run</code>函数为每个子命令对象创建了一个<code>XmlManifest</code>对象，该对象包含两个<code>MetaProject</code>对象，一个描述repo仓库，另一个描述manifest仓库。那么项目对象存储在哪里呢？我们可以想到的一种可能是项目对象也存储在XmlManifest对象中（也确实是这样）。</p>
<p>其实并不是所有的命令都需要知道项目仓库信息的，比如<code>init</code>命令。init命令仅仅下载一个manifest仓库，在manifest仓库下载下来之前，它也不可能有项目相关的对象。</p>
<p>一个需要使用项目仓库信息的命令是<code>sync</code>，它要下载所有的项目到本地，自然需要每一个项目的所有信息。XmlManifest对象有一个属性装饰器函数，它会在你获取XmlManifest对象时从清单文件里解析并创建出所有的项目对象并存储在一个列表中。</p>
<p>知道了所有所需要的信息之后<code>Cmd</code>对象就调用它自己实现的<code>Execute</code>函数来完成具体的工作。</p>
<p>下看我们来看以上这些分析的源代码。</p>
<h2 id="导入all-commands" class="article-heading"><a href="#导入all-commands" class="headerlink" title="导入all_commands"></a>导入all_commands<a class="article-anchor" href="#导入all-commands" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subcmds <span class="keyword">import</span> all_commands</span><br></pre></td></tr></table></figure>
<p>该导入操作会调用<code>subcmds</code>包的初始化脚本<code>__init__.py</code>，该脚本实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_commands = &#123;&#125;</span><br><span class="line"></span><br><span class="line">my_dir = os.path.dirname(__file__)</span><br><span class="line"><span class="keyword">for</span> py <span class="keyword">in</span> os.listdir(my_dir):</span><br><span class="line">  <span class="keyword">if</span> py == <span class="string">'__init__.py'</span>:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> py.endswith(<span class="string">'.py'</span>):</span><br><span class="line">    name = py[:<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">    clsn = name.capitalize()</span><br><span class="line">    <span class="keyword">while</span> clsn.find(<span class="string">'_'</span>) &gt; <span class="number">0</span>:</span><br><span class="line">      h = clsn.index(<span class="string">'_'</span>)</span><br><span class="line">      clsn = clsn[<span class="number">0</span>:h] + clsn[h + <span class="number">1</span>:].capitalize()</span><br><span class="line"></span><br><span class="line">    mod = __import__(__name__,</span><br><span class="line">                     globals(),</span><br><span class="line">                     locals(),</span><br><span class="line">                     [<span class="string">'%s'</span> % name])</span><br><span class="line">    mod = getattr(mod, name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      cmd = getattr(mod, clsn)()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">      <span class="keyword">raise</span> SyntaxError(<span class="string">'%s/%s does not define class %s'</span> % (</span><br><span class="line">                         __name__, py, clsn))</span><br><span class="line"></span><br><span class="line">    name = name.replace(<span class="string">'_'</span>, <span class="string">'-'</span>)</span><br><span class="line">    cmd.NAME = name</span><br><span class="line">    all_commands[name] = cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'help'</span> <span class="keyword">in</span> all_commands:</span><br><span class="line">  all_commands[<span class="string">'help'</span>].commands = all_commands</span><br></pre></td></tr></table></figure>
<p>首先定义一个空的<code>all_commands</code>列表，获取<code>__init__.py</code>文件所在目录下的所有文件，除<code>__init__.py</code>文件外，针对其它每个文件名name，去除文件名后缀，使用<code>__import__</code>导入该模块，这样每个子命令模块的类对象就创建成功了。</p>
<p>继续使用该文件名name，使首字母大写，使以<code>&#39;_&#39;</code>分隔的单词首字母大写得到该文件名对应的类名，然后使用<code>getattr</code>函数取得子命令模块，再取得之前导入时创建的对应的类对象。把该类对象添加到以名文件名为索引的<code>all_commands</code>列表中，其中文件名中的<code>&#39;_&#39;</code>要替换为<code>&#39;-&#39;</code>。这样就得到了所有子命令的类对象列表。如果要添加子命令，只需继承自<code>Command</code>类，并实现其<code>Execute</code>纯虚函数即可。</p>
<h2 id="Main函数" class="article-heading"><a href="#Main函数" class="headerlink" title="_Main函数"></a>_Main函数<a class="article-anchor" href="#Main函数" aria-hidden="true"></a></h2><p>main.py文件入口调用<code>_Main</code>函数。该函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  opt, argv = opt.parse_args(argv)</span><br><span class="line"></span><br><span class="line">  repo = _Repo(opt.repodir)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      result = repo._Run(argv) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">      close_ssh()</span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>main函数首先实例化一个<code>_Repo</code>对象，初始化ssh，http，然后直接调用<code>_Repo</code>实例的<code>_Run</code>函数。</p>
<h2 id="Repo类" class="article-heading"><a href="#Repo类" class="headerlink" title="_Repo类"></a>_Repo类<a class="article-anchor" href="#Repo类" aria-hidden="true"></a></h2><p><code>_Repo</code>类主要实现了<code>_Run</code>函数，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Repo</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repodir)</span>:</span></span><br><span class="line">    self.repodir = repodir</span><br><span class="line">    self.commands = all_commands</span><br><span class="line">    <span class="comment"># add 'branch' as an alias for 'branches'</span></span><br><span class="line">    all_commands[<span class="string">'branch'</span>] = all_commands[<span class="string">'branches'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_Run</span><span class="params">(self, argv)</span>:</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      cmd = self.commands[name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">      print(<span class="string">"repo: '%s' is not a repo command.  See 'repo help'."</span> % name,</span><br><span class="line">            file=sys.stderr)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    cmd.repodir = self.repodir</span><br><span class="line">    cmd.manifest = XmlManifest(cmd.repodir)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      result = cmd.Execute(copts, cargs)</span><br><span class="line">    <span class="keyword">except</span> (DownloadError, ManifestInvalidRevisionError,</span><br><span class="line">        NoManifestException) <span class="keyword">as</span> e:</span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><code>_Run</code>函数从<code>all_commands</code>列表中取得对应 <strong>子命令</strong> 对象（<code>cmd = self.commands[name]</code>）。设置该子命令对象的repo仓库地址，同时为该子命令对象创建一个manifest对象（<code>cmd.repodir = self.repodir</code>， <code>cmd.manifest = XmlManifest(cmd.repodir)</code>），repodir是我们前面创建的<code>.repo</code>目录（即整个AOSP的<code>.repo</code>库），XmlManifest对象又会创建两个<code>MetaProject</code>对象来管理repo仓库和manifest仓库，同时XmlManifest对象会通过自己的装饰器函数获取后续操作所需的大部分信息（如用户名，邮箱等等）。</p>
<p>最后调用 <strong>子命令</strong> 的<code>Execute</code>函数，执行该子命令的相应操作。所有的子命令都实现了<code>Execute</code>函数，使用该函数完成相应功能的操作。</p>
<h2 id="XmlManifest类" class="article-heading"><a href="#XmlManifest类" class="headerlink" title="XmlManifest类"></a>XmlManifest类<a class="article-anchor" href="#XmlManifest类" aria-hidden="true"></a></h2><p><code>XmlManifest</code>类在每个子命令类对象中描述该子命令操作所需要的基础信息，如.repo地址及所在目录，manifest文件路径，repo和manifest仓库对象以及所有要管理的项目对象。</p>
<p>我们摘取<code>XmlManifest</code>类的几个方法来看：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlManifest</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""manages the repo configuration file"""</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repodir)</span>:</span></span><br><span class="line"></span><br><span class="line">    self.repoProject = MetaProject(self, <span class="string">'repo'</span>,</span><br><span class="line">      gitdir   = os.path.join(repodir, <span class="string">'repo/.git'</span>),</span><br><span class="line">      worktree = os.path.join(repodir, <span class="string">'repo'</span>))</span><br><span class="line"></span><br><span class="line">    self.manifestProject = MetaProject(self, <span class="string">'manifests'</span>,</span><br><span class="line">      gitdir   = os.path.join(repodir, <span class="string">'manifests.git'</span>),</span><br><span class="line">      worktree = os.path.join(repodir, <span class="string">'manifests'</span>))</span><br><span class="line"></span><br><span class="line">    self._Unload()</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">projects</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._Load()</span><br><span class="line">    <span class="keyword">return</span> list(self._paths.values())</span><br></pre></td></tr></table></figure></p>
<p>先来看看初始化函数，<code>XmlManifest</code>类在初始化的时候会创建两个<code>MetaProject</code>类对象，一个对象是用来描述repo仓库，另一个用来描述manifest仓库。该<code>MetaProject</code>类派生自<code>Project</code>类，其实整个AOSP中的除了repo和manifest其它所有项目对象都是<code>Project</code>类型。</p>
<p>由于Repo和Manifest也是Git仓库，所以我们也需要创建一个Project对象来描述它们，不过，由于它们是比较特殊的Git仓库（用来描述AOSP子项目元信息的Git仓库），所以我们就使用另外一个类型为<code>MetaProject</code>的对象来描述它们。</p>
<p><code>def projects(self)</code>有一个属性装饰器，它会在你访问该属性或它所属对象时自动运行。它使用内部函数<code>_Load()</code>读取并解析manifest清单文件，并对每个项目创建<code>Project</code>类对象。就像后面会分析的一样，在创建每个项目对象时会分别指定它们的仓库地址与工作区地址，以达到工作区和仓库分离的目标。</p>
<h2 id="MetaProject类" class="article-heading"><a href="#MetaProject类" class="headerlink" title="MetaProject类"></a>MetaProject类<a class="article-anchor" href="#MetaProject类" aria-hidden="true"></a></h2><p><code>MetaProject</code>类继承自<code>Project</code>类，它的构造函数直接调用其基类的构造函数，实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaProject</span><span class="params">(Project)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, manifest, name, gitdir, worktree)</span>:</span></span><br><span class="line">    Project.__init__(self,</span><br><span class="line">                     manifest=manifest,</span><br><span class="line">                     name=name,</span><br><span class="line">                     gitdir=gitdir,</span><br><span class="line">                     objdir=gitdir,</span><br><span class="line">                     worktree=worktree,</span><br><span class="line">                     remote=RemoteSpec(<span class="string">'origin'</span>),</span><br><span class="line">                     relpath=<span class="string">'.repo/%s'</span> % name,</span><br><span class="line">                     revisionExpr=<span class="string">'refs/heads/master'</span>,</span><br><span class="line">                     revisionId=<span class="literal">None</span>,</span><br><span class="line">                     groups=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>在创建<code>repoProject</code>对象时传入的为repo仓库相关的参数（<code>[manifest=&#39;repo&#39;, gitdir=&#39;.repo/repo/.git&#39;,  worktree=&#39;.repo/repo&#39;]</code>），在创建<code>manifestProject</code>对象时传入manifest仓库相关的参数（<code>[manifest=&#39;manifests&#39;, gitdir=&#39;.repo/manifests.git&#39;, worktree=&#39;.repo/manifests&#39;]</code>）。</p>
<p>重点记住下面三个参数，后面会再说明：</p>
<ul>
<li>gitdir Git仓库存(.git)的放位置</li>
<li>objdir Git仓库对象文件存放位置</li>
<li>worktree 工作区位置</li>
</ul>
<p>这里传给基类的gitdir与objdir相同，这就使得repo和manifest仓库的仓库与对象存储在相同的位置。我们后面会看到在创建项目对象时，传入的gitdir与objdir是不相同的。</p>
<p>另外比较repo仓库与manifest仓库在创建时传入的参数，我们发现repo仓库的Git库和工作区是在同一个目录，而manifest仓库的Git库与工作区不是一个目录。为什么要不同呢？</p>
<p>先来看看下载完成后的带工作区的manifest仓库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">~/WORKING_DIRECTORY/.repo/manifests/.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 8</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  26 4月  22 23:52 config -&gt; ../../manifests.git/config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  31 4月  22 23:52 description -&gt; ../../manifests.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  24 4月  22 23:52 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  25 4月  22 23:52 hooks -&gt; ../../manifests.git/hooks</span><br><span class="line">-rw-rw-r--. 1 zyl zyl 145 4月  22 23:52 index</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  24 4月  22 23:52 info -&gt; ../../manifests.git/info</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  24 4月  22 23:52 logs -&gt; ../../manifests.git/logs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  27 4月  22 23:52 objects -&gt; ../../manifests.git/objects</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  31 4月  22 23:52 packed-refs -&gt; ../../manifests.git/packed-refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  24 4月  22 23:52 refs -&gt; ../../manifests.git/refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  28 4月  22 23:52 rr-cache -&gt; ../../manifests.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  23 4月  22 23:52 svn -&gt; ../../manifests.git/svn</span><br></pre></td></tr></table></figure></p>
<p>我们知道，repo仓库是前面通过引导文件下载的，最终是通过类似<code>git clone</code>的方式下载下来的，工作区和仓库是同一个目录。因此在创建管理repo仓库的对象时要传入相同的gitdir与worktree，而manifest仓库是由完整的Repo仓库的main.py模块下载的，它的下载与后面项目的下载类似，是仓库与工作区分开的。</p>
<p>为什么要创建一个<code>MetaProject</code>类，直接使用<code>Project</code>类不行吗？</p>
<p>我们来看看这两个类的区别，<code>MetaProject</code>类继承自<code>Project</code>类，但额外实现了两个函数，<code>PreSync</code>与<code>MetaBranchSwitch</code>。这两个函数配合主要是为了实现检出分支或更新仓库时使用已有的分支，而不是使用manifest文件里revision属性指定的分支。再者这两个库是为了管理项目的，并不是越新越好，而是要检出稳定的版本，这些都和项目类不同。</p>
<p>下面来看它的基类<code>Project</code>类的<code>__init__</code>函数。</p>
<h2 id="Project类的init函数" class="article-heading"><a href="#Project类的init函数" class="headerlink" title="Project类的init函数"></a>Project类的<strong>init</strong>函数<a class="article-anchor" href="#Project类的init函数" aria-hidden="true"></a></h2><p><code>Project</code>类对象用来描述一个AOSP子项目的各项信息，以及封装对git的基本操作，其<code>__init__</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Project</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="comment"># These objects can be shared between several working trees.</span></span><br><span class="line">  shareable_files = [<span class="string">'description'</span>, <span class="string">'info'</span>]</span><br><span class="line">  shareable_dirs = [<span class="string">'hooks'</span>, <span class="string">'objects'</span>, <span class="string">'rr-cache'</span>, <span class="string">'svn'</span>]</span><br><span class="line">  <span class="comment"># These objects can only be used by a single working tree.</span></span><br><span class="line">  working_tree_files = [<span class="string">'config'</span>, <span class="string">'packed-refs'</span>, <span class="string">'shallow'</span>]</span><br><span class="line">  working_tree_dirs = [<span class="string">'logs'</span>, <span class="string">'refs'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">               manifest,</span></span></span><br><span class="line"><span class="function"><span class="params">               name,</span></span></span><br><span class="line"><span class="function"><span class="params">               remote,</span></span></span><br><span class="line"><span class="function"><span class="params">               gitdir,</span></span></span><br><span class="line"><span class="function"><span class="params">               objdir,</span></span></span><br><span class="line"><span class="function"><span class="params">               worktree,</span></span></span><br><span class="line"><span class="function"><span class="params">               relpath,</span></span></span><br><span class="line"><span class="function"><span class="params">               revisionExpr,</span></span></span><br><span class="line"><span class="function"><span class="params">               revisionId,</span></span></span><br><span class="line"><span class="function"><span class="params">               rebase=True,</span></span></span><br><span class="line"><span class="function"><span class="params">               groups=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               sync_c=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               sync_s=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               clone_depth=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               upstream=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               parent=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               is_derived=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               dest_branch=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               optimized_fetch=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               old_revision=None)</span>:</span></span><br><span class="line">    self.manifest = manifest</span><br><span class="line">    self.name = name</span><br><span class="line">    self.remote = remote</span><br><span class="line">    self.gitdir = gitdir.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    self.objdir = objdir.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">if</span> worktree:</span><br><span class="line">      self.worktree = worktree.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.worktree = <span class="literal">None</span></span><br><span class="line">    self.relpath = relpath</span><br><span class="line">    self.revisionExpr = revisionExpr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>   revisionId <span class="keyword">is</span> <span class="literal">None</span> \</span><br><span class="line">     <span class="keyword">and</span> revisionExpr \</span><br><span class="line">     <span class="keyword">and</span> IsId(revisionExpr):</span><br><span class="line">      self.revisionId = revisionExpr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.revisionId = revisionId</span><br><span class="line"></span><br><span class="line">    self.rebase = rebase</span><br><span class="line">    self.groups = groups</span><br><span class="line">    self.sync_c = sync_c</span><br><span class="line">    self.sync_s = sync_s</span><br><span class="line">    self.clone_depth = clone_depth</span><br><span class="line">    self.upstream = upstream</span><br><span class="line">    self.parent = parent</span><br><span class="line">    self.is_derived = is_derived</span><br><span class="line">    self.optimized_fetch = optimized_fetch</span><br><span class="line">    self.subprojects = []</span><br><span class="line"></span><br><span class="line">    self.snapshots = &#123;&#125;</span><br><span class="line">    self.copyfiles = []</span><br><span class="line">    self.linkfiles = []</span><br><span class="line">    self.annotations = []</span><br><span class="line">    self.config = GitConfig.ForRepository(</span><br><span class="line">                    gitdir=self.gitdir,</span><br><span class="line">                    defaults=self.manifest.globalConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.worktree:</span><br><span class="line">      self.work_git = self._GitGetByExec(self, bare=<span class="literal">False</span>, gitdir=gitdir)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.work_git = <span class="literal">None</span></span><br><span class="line">    self.bare_git = self._GitGetByExec(self, bare=<span class="literal">True</span>, gitdir=gitdir)</span><br><span class="line">    self.bare_ref = GitRefs(gitdir)</span><br><span class="line">    self.bare_objdir = self._GitGetByExec(self, bare=<span class="literal">True</span>, gitdir=objdir)</span><br><span class="line">    self.dest_branch = dest_branch</span><br><span class="line">    self.old_revision = old_revision</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This will be filled in if a project is later identified to be the</span></span><br><span class="line">    <span class="comment"># project containing repo hooks.</span></span><br><span class="line">    self.enabled_repo_hooks = []</span><br></pre></td></tr></table></figure></p>
<p>该函数各参数的意义注释中有详细的说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>manifest</code></td>
<td>XmlManifest对象</td>
</tr>
<tr>
<td><code>name</code></td>
<td>项目名称</td>
</tr>
<tr>
<td><code>remote</code></td>
<td>项目对应的远程仓库信息</td>
</tr>
<tr>
<td><code>gitdir</code></td>
<td>Git仓库绝对路径</td>
</tr>
<tr>
<td><code>objdir</code></td>
<td>Git仓库对象存储的绝对路径</td>
</tr>
<tr>
<td><code>worktree</code></td>
<td>工作目录的绝对路径</td>
</tr>
<tr>
<td><code>relpath</code></td>
<td>工作目录相对于AOS根目录的相对路径</td>
</tr>
<tr>
<td><code>revisionExpr</code></td>
<td>manifest.xml中关于该项目的<code>revision</code>属性</td>
</tr>
<tr>
<td><code>revisionId</code></td>
<td>checkout out时的commit id</td>
</tr>
<tr>
<td><code>rebase</code></td>
<td>manifest.xml中关于该项目的<code>rebase</code>属性</td>
</tr>
<tr>
<td><code>groups</code></td>
<td>manifest.xml中关于该项目的<code>groups</code>属性</td>
</tr>
<tr>
<td><code>sync_c</code></td>
<td>manifest.xml中关于该项目的<code>sync_c</code>属性</td>
</tr>
<tr>
<td><code>sync_s</code></td>
<td>manifest.xml中关于该项目的<code>sync_s</code>属性</td>
</tr>
<tr>
<td><code>upstream</code></td>
<td>manifest.xml中关于该项目的<code>upstream</code>属性</td>
</tr>
<tr>
<td><code>parent</code></td>
<td>当前项目的父项目</td>
</tr>
<tr>
<td><code>is_derived</code></td>
<td>如果一个项目含有子模块（也是一个Git仓库），那么这些子模块也会用一个<code>Project</code>对象来描述，这些<code>Project</code>的<code>is_derived</code>属性会设置为true</td>
</tr>
<tr>
<td><code>dest_branch</code></td>
<td>默认的codereview分支，如果不指定则会取<code>revision</code>属性作为默认的codereview分支。</td>
</tr>
</tbody>
</table>
<p>前面已经提到，在项目属性中分别指定gitdir，objdir，worktree是因为在AOSP中，每一个子项目的存储对象、git仓库以及工作区目录是分开的。AOSP中项目的工作目录位于AOSP根目录下，Git仓库位于<code>.repo/repo/projects</code>目录下，而存储对象放在<code>.repo/repo/project-objects</code>目录下。</p>
<p>此外，每一个AOSP子项目的工作目录也有一个.git目录，不过这个.git目录下的大部分文件都是一个符号链接，指向<code>.repo/repo/projects</code>目录下对应的项目的Git目录（像manifest仓库那样）下的文件。这样，我们就可以在AOSP子项目的工作目录下执行Git命令，就像它的仓库就在本地一样，也可以在其Git仓库下执行Git命令。一般来说，要访问到工作目录的命令（例如<code>git status</code>）需要在工作目录下执行，而不需要访问工作目录（例如<code>git log</code>）可以在Git目录下执行。</p>
<p>下面来看这两个成员变量<code>work_git</code>和<code>bare_git</code>，它们指向的都是一个<code>_GitGetByExec</code>对象，该对象调用GitCommand类中的命令的执行Git操作。其中，前者在执行Git命令的时候，会将当前目录设置为项目的工作目录，而后者在执行的时候，不会设置当前目录，但是会将环境变量<code>GIT_DIR</code>的值设置为项目的Git目录，也就是<code>.repo/projects</code>目录下面的那些目录。这就是Repo能将仓库和工作区分开存储的真正原因。通过这种方式，子命令对象可以在工作区还没有创建.git时执行Git命令。</p>
<p>还是前面的问题，为什么要把这三个目录分开存放呢？通过Project类开头的注释可以看出这样设计可以在多个不同的工作区里共离一些东西。同时把对象存储在一起也可以更方便的管理与存储。</p>
<p>我们看一个项目的目录结构：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GIT_OBJECT_DIRECTORY目录下</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">.repo/project-objects/site.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 40</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 branches</span><br><span class="line">-rw-rw-r--.   1 zyl zyl   66 4月  23 00:01 config</span><br><span class="line">-rw-rw-r--.   1 zyl zyl   73 4月  23 00:01 description</span><br><span class="line">-rw-rw-r--.   1 zyl zyl   23 4月  23 00:01 HEAD</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 hooks</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 info</span><br><span class="line">drwxrwxr-x. 223 zyl zyl 4096 5月  23 19:27 objects</span><br><span class="line">drwxrwxr-x.   4 zyl zyl 4096 4月  23 00:01 refs</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 rr-cache</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIT_DIR目录下</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">.repo/projects/site.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 28</span><br><span class="line">drwxrwxr-x. 2 zyl zyl 4096 4月  23 00:01 branches</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  337 4月  30 22:24 config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   42 4月  23 00:01 description -&gt; ../../project-objects/site.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  453 5月  12 21:08 FETCH_HEAD</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   23 4月  23 00:01 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   36 4月  23 00:01 hooks -&gt; ../../project-objects/site.git/hooks</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   35 4月  23 00:01 info -&gt; ../../project-objects/site.git/info</span><br><span class="line">drwxrwxr-x. 3 zyl zyl 4096 4月  23 12:33 logs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   38 4月  23 00:01 objects -&gt; ../../project-objects/site.git/objects</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   39 4月  23 00:02 packed-refs</span><br><span class="line">drwxrwxr-x. 5 zyl zyl 4096 4月  23 00:16 refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   39 4月  23 00:01 rr-cache -&gt; ../../project-objects/site.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   34 4月  23 00:01 svn -&gt; ../../project-objects/site.git/svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作区下的.git</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">site/.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 28</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    59 5月  15 23:17 COMMIT_EDITMSG</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    36 4月  23 00:16 config -&gt; ../../.repo/projects/site.git/config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    48 4月  23 00:16 description -&gt; ../../.repo/project-objects/site.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    85 5月  23 21:06 FETCH_HEAD</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    23 4月  30 22:24 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    42 4月  23 00:16 hooks -&gt; ../../.repo/project-objects/site.git/hooks</span><br><span class="line">-rw-rw-r--. 1 zyl zyl 11733 5月  23 19:30 index</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    41 4月  23 00:16 info -&gt; ../../.repo/project-objects/site.git/info</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    34 4月  23 00:16 logs -&gt; ../../.repo/projects/site.git/logs</span><br><span class="line">-rw-rw-r--. 1 zyl zyl     0 5月  15 23:17 MERGE_RR</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    44 4月  23 00:16 objects -&gt; ../../.repo/project-objects/site.git/objects</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    41 5月  23 19:27 ORIG_HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    41 4月  23 00:16 packed-refs -&gt; ../../.repo/projects/site.git/packed-refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    34 4月  23 00:16 refs -&gt; ../../.repo/projects/site.git/refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    45 4月  23 00:16 rr-cache -&gt; ../../.repo/project-objects/site.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    40 4月  23 00:16 svn -&gt; ../../.repo/project-objects/site.git/svn</span><br></pre></td></tr></table></figure></p>
<h2 id="远程仓库的路径" class="article-heading"><a href="#远程仓库的路径" class="headerlink" title="远程仓库的路径"></a>远程仓库的路径<a class="article-anchor" href="#远程仓库的路径" aria-hidden="true"></a></h2><p>项目仓库的地址是如何得到的呢，Repo使用如下地址作为项目的fetch地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;remote_fetch&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>.git</span><br></pre></td></tr></table></figure></p>
<p>其中remote_fetch就是manifest.xml文件中remote元素的fetch属性，该属性支持两种路径格式–绝对路径与相对路径。</p>
<ul>
<li>绝对路径： 如果指定绝对路径，则项目的地址就是上面格式的组合。</li>
<li>相对路径： 如果指定相对路径，则该路径为相对于命令行参数<code>-u</code>的路径，即相对于manifest仓库的路径。</li>
</ul>
<p>例如，如果在<code>repo init</code>时给的<code>-u</code>命令参数为<code>https://android.googlesource.com/platform/manifest</code>，并指定remote的fetch属性如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"aosp"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">fetch</span>=<span class="string">".."</span></span></span><br><span class="line"><span class="tag">         <span class="attr">review</span>=<span class="string">"https://android-review.googlesource.com/"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>则项目的路径为：<code>https://android.googlesource.com/platform/&lt;project_name&gt;.git</code>。</p>
<h1 id="REPO-INIT" class="article-heading"><a href="#REPO-INIT" class="headerlink" title="REPO INIT"></a>REPO INIT<a class="article-anchor" href="#REPO-INIT" aria-hidden="true"></a></h1><p>前面提到每个子命令都实现了<code>Execute</code>函数，用该函数来实现功能。前面引导加载的过程都相似，下面介绍<code>Init</code>类的<code>Execute</code>函数。<code>repo init</code>使用该部分同步manifest仓库。</p>
<h2 id="Init类的Execute函数" class="article-heading"><a href="#Init类的Execute函数" class="headerlink" title="Init类的Execute函数"></a>Init类的Execute函数<a class="article-anchor" href="#Init类的Execute函数" aria-hidden="true"></a></h2><p><code>init</code>命令的<code>Execute</code>实现如下，该函数主要使用两个内部函数<code>_SyncManifest</code>和<code>_LinkManifest</code>来完成功能：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Init</span><span class="params">(InteractiveCommand, MirrorSafeCommand)</span>:</span>  </span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">    git_require(MIN_GIT_VERSION, fail=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    self._SyncManifest(opt)</span><br><span class="line">    self._LinkManifest(opt.manifest_name)</span><br><span class="line"></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p><code>_SyncManifest</code>函数同步manifest仓库，<code>_LinkManifest</code>函数创建默认的manifest链接。下面具体分析。</p>
<h2 id="Init类的-SyncManifest函数" class="article-heading"><a href="#Init类的-SyncManifest函数" class="headerlink" title="Init类的_SyncManifest函数"></a>Init类的_SyncManifest函数<a class="article-anchor" href="#Init类的-SyncManifest函数" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_SyncManifest</span><span class="params">(self, opt)</span>:</span></span><br><span class="line">  m = self.manifest.manifestProject</span><br><span class="line">  is_new = <span class="keyword">not</span> m.Exists</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_new:</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    mirrored_manifest_git = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    m._InitGitDir(mirror_git=mirrored_manifest_git)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> opt.manifest_branch:</span><br><span class="line">      m.revisionExpr = opt.manifest_branch</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      m.revisionExpr = <span class="string">'refs/heads/master'</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> opt.manifest_branch:</span><br><span class="line">      m.revisionExpr = opt.manifest_branch</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      m.PreSync()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> opt.manifest_url:</span><br><span class="line">    r = m.GetRemote(m.remote.name)</span><br><span class="line">    r.url = opt.manifest_url</span><br><span class="line">    r.ResetFetch()</span><br><span class="line">    r.Save()</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> m.Sync_NetworkHalf(is_new=is_new):</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> opt.manifest_branch:</span><br><span class="line">    m.MetaBranchSwitch()</span><br><span class="line"></span><br><span class="line">  syncbuf = SyncBuffer(m.config)</span><br><span class="line">  m.Sync_LocalHalf(syncbuf)</span><br><span class="line">  syncbuf.Finish()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_new <span class="keyword">or</span> m.CurrentBranch <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m.StartBranch(<span class="string">'default'</span>):</span><br><span class="line">      print(<span class="string">'fatal: cannot create default in manifest'</span>, file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先设置前面创建的<code>MetaProject</code>类型的实例<code>manifestProject</code>对象为<code>m</code>，调用<code>m</code>的<code>_InitGitDir</code>函数创建仓库与对象目录，实际调用的是基类的<code>Project</code>类中的<code>_InitGitDir</code>函数。</li>
<li>设置<code>revisionExpr</code>变量指定需要获取的manifest仓库的分支。如果没有用<code>-b</code>指定则取默认的<code>master</code>分支。</li>
<li>使用<code>GetRemote</code>函数获取（创建）名字为<code>m.remote.name</code>的一个Remote远程仓库对象（第一次获取时该对象不存在，则创建该对象），配置该远程仓库对象的url，设置它的引用并保存配置。</li>
<li>使用<code>Sync_NetworkHalf</code>同步manifest仓库。</li>
<li>使用<code>Sync_LocalHalf</code>捡出指定的分支。</li>
</ul>
<h2 id="Project类图" class="article-heading"><a href="#Project类图" class="headerlink" title="Project类图"></a>Project类图<a class="article-anchor" href="#Project类图" aria-hidden="true"></a></h2><p>下图主列出了Project类的与库的下载与检出相关的两个函数，命令<code>init</code>和<code>sync</code>就是使用这两个函数来完成项目的下载与检出的。<br><img src="/img/class-project.png" alt="project"><br>其中repo的Git仓库对象repoProject和manifest的Git仓库对象manifestProject从MetaProject类产生，其它项目对象都是直接从Project类产生。</p>
<p>下面重点看<code>Sync_NetworkHalf</code>与<code>Sync_LocalHalf</code>函数。</p>
<h2 id="Project类的Sync-NetworkHalf函数" class="article-heading"><a href="#Project类的Sync-NetworkHalf函数" class="headerlink" title="Project类的Sync_NetworkHalf函数"></a>Project类的Sync_NetworkHalf函数<a class="article-anchor" href="#Project类的Sync-NetworkHalf函数" aria-hidden="true"></a></h2><p><code>Sync_NetworkHalf</code>函数首先调用<code>_InitGitDir</code>函数创建目录，然后调用<code>_ApplyCloneBundle</code>函数获取clone.bundle文件，而<code>_ApplyCloneBundle</code>函数通过调用<code>_FetchBundle</code>获取文件。这些步骤与前面获取repo仓库的bundle文件时差不多。</p>
<p><code>Sync_NetworkHalf</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sync_NetworkHalf</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">    quiet=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    is_new=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    current_branch_only=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    force_sync=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    clone_bundle=True,</span></span></span><br><span class="line"><span class="function"><span class="params">    no_tags=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    archive=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    optimized_fetch=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    prune=False)</span>:</span></span><br><span class="line">  <span class="string">"""Perform only the network IO portion of the sync process.</span></span><br><span class="line"><span class="string">     Local working directory/branch state is not affected.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_new:</span><br><span class="line">    self._InitGitDir(force_sync=force_sync)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self._UpdateHooks()</span><br><span class="line">  self._InitRemote()</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> clone_bundle \</span><br><span class="line">  <span class="keyword">and</span> alt_dir <span class="keyword">is</span> <span class="literal">None</span> \</span><br><span class="line">  <span class="keyword">and</span> self._ApplyCloneBundle(initial=is_new, quiet=quiet):</span><br><span class="line">    is_new = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  need_to_fetch = <span class="keyword">not</span> (optimized_fetch <span class="keyword">and</span> \</span><br><span class="line">    (ID_RE.match(self.revisionExpr) <span class="keyword">and</span> self._CheckForSha1()))</span><br><span class="line">  <span class="keyword">if</span> (need_to_fetch</span><br><span class="line">      <span class="keyword">and</span> <span class="keyword">not</span> self._RemoteFetch(initial=is_new, quiet=quiet, alt_dir=alt_dir,</span><br><span class="line">                                current_branch_only=current_branch_only,</span><br><span class="line">                                no_tags=no_tags, prune=prune)):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> self.worktree:</span><br><span class="line">    self._InitMRef()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self._InitMirrorHead()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      os.remove(os.path.join(self.gitdir, <span class="string">'FETCH_HEAD'</span>))</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p><code>Sync_NetworkHalf</code>函数主要完成库对象的下载，工作区和分支状态不受影响。如果调用时<code>is_new</code>置为<code>true</code>表示一个新的仓库，会调用<code>_InitGitDir</code>来创建仓库的相关信息。否则调用<code>_UpdateHooks</code>更新引用。</p>
<h2 id="Project类的-InitGitDir函数" class="article-heading"><a href="#Project类的-InitGitDir函数" class="headerlink" title="Project类的_InitGitDir函数"></a>Project类的_InitGitDir函数<a class="article-anchor" href="#Project类的-InitGitDir函数" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_InitGitDir</span><span class="params">(self, mirror_git=None, force_sync=False)</span>:</span></span><br><span class="line">  init_git_dir = <span class="keyword">not</span> os.path.exists(self.gitdir)</span><br><span class="line">  init_obj_dir = <span class="keyword">not</span> os.path.exists(self.objdir)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize the bare repository, which contains all of the objects.</span></span><br><span class="line">    <span class="keyword">if</span> init_obj_dir:</span><br><span class="line">      os.makedirs(self.objdir)</span><br><span class="line">      self.bare_objdir.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If we have a separate directory to hold refs, initialize it as well.</span></span><br><span class="line">    <span class="keyword">if</span> self.objdir != self.gitdir:</span><br><span class="line">      <span class="keyword">if</span> init_git_dir:</span><br><span class="line">        os.makedirs(self.gitdir)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> init_obj_dir <span class="keyword">or</span> init_git_dir:</span><br><span class="line">        self._ReferenceGitDir(self.objdir, self.gitdir, share_refs=<span class="literal">False</span>,</span><br><span class="line">                              copy_all=<span class="literal">True</span>)</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> init_git_dir:</span><br><span class="line">      mp = self.manifest.manifestProject</span><br><span class="line">      </span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      self._UpdateHooks()</span><br><span class="line"></span><br><span class="line">      m = self.manifest.manifestProject.config</span><br><span class="line">      <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'user.name'</span>, <span class="string">'user.email'</span>]:</span><br><span class="line">        <span class="keyword">if</span> m.Has(key, include_defaults=<span class="literal">False</span>):</span><br><span class="line">          self.config.SetString(key, m.GetString(key))</span><br><span class="line">      <span class="keyword">if</span> self.manifest.IsMirror:</span><br><span class="line">        self.config.SetString(<span class="string">'core.bare'</span>, <span class="string">'true'</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        self.config.SetString(<span class="string">'core.bare'</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>_InitGitDir</code>函数首先判断当前项目的gitdir和objdir是否存在，如果objdir不存在，则创建objdir目录。manifest仓库的对象存储位置与仓库是同一目录，gitdir与objdir可以不同，如果objdir与gitdir不同，则创建gitdir目录，并创建引用，以便仓库可以找到对象的存储位置。然后调用<code>_UpdateHooks()</code>函数创建hooks目录并创建<code>commit-msg -&gt; ../../repo/hooks/commit-msg</code>，<code>pre-auto-gc -&gt; ../../repo/hooks/pre-auto-gc</code>两个连接连接向repo仓库下面hooks目录下的对应文件，这两个勾子文件是在commit msg中生成ChangeId的。然后设置用户名与用户邮件地址，设置该仓库是否是一个bare仓库。</p>
<p><code>Project</code>类定义哪些引用是所有工作树共享的，哪些引用是工作区私有的。对于所有工作区共享的引用实际上是<code>.repo/projects/&lt;PROJECT_NAME&gt;.git</code>目录到<code>.repo/project-objects/&lt;PROJECT_NAME&gt;.git</code>的链接。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These objects can be shared between several working trees.</span></span><br><span class="line">shareable_files = [<span class="string">'description'</span>, <span class="string">'info'</span>]</span><br><span class="line">shareable_dirs = [<span class="string">'hooks'</span>, <span class="string">'objects'</span>, <span class="string">'rr-cache'</span>, <span class="string">'svn'</span>]</span><br><span class="line"><span class="comment"># These objects can only be used by a single working tree.</span></span><br><span class="line">working_tree_files = [<span class="string">'config'</span>, <span class="string">'packed-refs'</span>, <span class="string">'shallow'</span>]</span><br><span class="line">working_tree_dirs = [<span class="string">'logs'</span>, <span class="string">'refs'</span>]</span><br></pre></td></tr></table></figure></p>
<p>下面看一个例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drwxrwxr-x. 2 zyl zyl 4096 4月  23 00:01 branches</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  337 4月  26 21:24 config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   42 4月  23 00:01 description -&gt; ../../project-objects/site.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  453 4月  29 14:40 FETCH_HEAD</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   23 4月  23 00:01 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   36 4月  23 00:01 hooks -&gt; ../../project-objects/site.git/hooks</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   35 4月  23 00:01 info -&gt; ../../project-objects/site.git/info</span><br><span class="line">drwxrwxr-x. 3 zyl zyl 4096 4月  23 12:33 logs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   38 4月  23 00:01 objects -&gt; ../../project-objects/site.git/objects</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   39 4月  23 00:02 packed-refs</span><br><span class="line">drwxrwxr-x. 5 zyl zyl 4096 4月  23 00:16 refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   39 4月  23 00:01 rr-cache -&gt; ../../project-objects/site.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   34 4月  23 00:01 svn -&gt; ../../project-objects/site.git/svn</span><br></pre></td></tr></table></figure></p>
<h2 id="ApplyCloneBundle函数实现" class="article-heading"><a href="#ApplyCloneBundle函数实现" class="headerlink" title="_ApplyCloneBundle函数实现"></a>_ApplyCloneBundle函数实现<a class="article-anchor" href="#ApplyCloneBundle函数实现" aria-hidden="true"></a></h2><p><code>_ApplyCloneBundle</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ApplyCloneBundle</span><span class="params">(self, initial=False, quiet=False)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> initial <span class="keyword">and</span> (self.manifest.manifestProject.config.GetString(<span class="string">'repo.depth'</span>) <span class="keyword">or</span> self.clone_depth):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  remote = self.GetRemote(self.remote.name)</span><br><span class="line">  bundle_url = remote.url + <span class="string">'/clone.bundle'</span></span><br><span class="line">  bundle_url = GitConfig.ForUser().UrlInsteadOf(bundle_url)</span><br><span class="line">  <span class="keyword">if</span> GetSchemeFromUrl(bundle_url) <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">      <span class="string">'http'</span>, <span class="string">'https'</span>, <span class="string">'persistent-http'</span>, <span class="string">'persistent-https'</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  bundle_dst = os.path.join(self.gitdir, <span class="string">'clone.bundle'</span>)</span><br><span class="line">  bundle_tmp = os.path.join(self.gitdir, <span class="string">'clone.bundle.tmp'</span>)</span><br><span class="line"></span><br><span class="line">  exist_dst = os.path.exists(bundle_dst)</span><br><span class="line">  exist_tmp = os.path.exists(bundle_tmp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> initial <span class="keyword">and</span> <span class="keyword">not</span> exist_dst <span class="keyword">and</span> <span class="keyword">not</span> exist_tmp:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> exist_dst:</span><br><span class="line">    exist_dst = self._FetchBundle(bundle_url, bundle_tmp, bundle_dst, quiet)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> exist_dst:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  cmd = [<span class="string">'fetch'</span>]</span><br><span class="line">  <span class="keyword">if</span> quiet:</span><br><span class="line">    cmd.append(<span class="string">'--quiet'</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> self.worktree:</span><br><span class="line">    cmd.append(<span class="string">'--update-head-ok'</span>)</span><br><span class="line">  cmd.append(bundle_dst)</span><br><span class="line">  <span class="keyword">for</span> f <span class="keyword">in</span> remote.fetch:</span><br><span class="line">    cmd.append(str(f))</span><br><span class="line">  cmd.append(<span class="string">'refs/tags/*:refs/tags/*'</span>)</span><br><span class="line"></span><br><span class="line">  ok = GitCommand(self, cmd, bare=<span class="literal">True</span>).Wait() == <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> os.path.exists(bundle_dst):</span><br><span class="line">    os.remove(bundle_dst)</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(bundle_tmp):</span><br><span class="line">    os.remove(bundle_tmp)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br></pre></td></tr></table></figure></p>
<p><code>_FetchBundle</code>函数检查有无代理，然后下载bundle文件，从<code>_FetchBundle</code>函数可以看出，只需要在环境变量中设置<code>http_proxy</code>变量指定代理地址就可以了。</p>
<h2 id="Sync-LocalHalf函数实现" class="article-heading"><a href="#Sync-LocalHalf函数实现" class="headerlink" title="Sync_LocalHalf函数实现"></a>Sync_LocalHalf函数实现<a class="article-anchor" href="#Sync-LocalHalf函数实现" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sync_LocalHalf</span><span class="params">(self, syncbuf, force_sync=False)</span>:</span></span><br><span class="line">  <span class="string">"""Perform only the local IO portion of the sync process.</span></span><br><span class="line"><span class="string">     Network access is not required.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  self._InitWorkTree(force_sync=force_sync)</span><br><span class="line">  all_refs = self.bare_ref.all</span><br><span class="line">  self.CleanPublishedCache(all_refs)</span><br><span class="line">  revid = self.GetRevisionId(all_refs)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_doff</span><span class="params">()</span>:</span></span><br><span class="line">    self._FastForward(revid)</span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line"></span><br><span class="line">  head = self.work_git.GetHead()</span><br><span class="line">  <span class="keyword">if</span> head.startswith(R_HEADS):</span><br><span class="line">    branch = head[len(R_HEADS):]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      head = all_refs[head]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">      head = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    branch = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> branch <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> syncbuf.detach_head:</span><br><span class="line">    <span class="comment"># Currently on a detached HEAD.  The user is assumed to</span></span><br><span class="line">    <span class="comment"># not have any local modifications worth worrying about.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> self.IsRebaseInProgress():</span><br><span class="line">      syncbuf.fail(self, _PriorSyncFailedError())</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == revid:</span><br><span class="line">      <span class="comment"># No changes; don't do anything further.</span></span><br><span class="line">      <span class="comment"># Except if the head needs to be detached</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> syncbuf.detach_head:</span><br><span class="line">        <span class="comment"># The copy/linkfile config may have changed.</span></span><br><span class="line">        self._CopyAndLinkFiles()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      lost = self._revlist(not_rev(revid), HEAD)</span><br><span class="line">      <span class="keyword">if</span> lost:</span><br><span class="line">        syncbuf.info(self, <span class="string">"discarding %d commits"</span>, len(lost))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self._Checkout(revid, quiet=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> GitError <span class="keyword">as</span> e:</span><br><span class="line">      syncbuf.fail(self, e)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> head == revid:</span><br><span class="line">    <span class="comment"># No changes; don't do anything further.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># The copy/linkfile config may have changed.</span></span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  branch = self.GetBranch(branch)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> branch.LocalMerge:</span><br><span class="line">    <span class="comment"># The current branch has no tracking configuration.</span></span><br><span class="line">    <span class="comment"># Jump off it to a detached HEAD.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    syncbuf.info(self,</span><br><span class="line">                 <span class="string">"leaving %s; does not track upstream"</span>,</span><br><span class="line">                 branch.name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self._Checkout(revid, quiet=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> GitError <span class="keyword">as</span> e:</span><br><span class="line">      syncbuf.fail(self, e)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  upstream_gain = self._revlist(not_rev(HEAD), revid)</span><br><span class="line">  pub = self.WasPublished(branch.name, all_refs)</span><br><span class="line">  <span class="keyword">if</span> pub:</span><br><span class="line">    not_merged = self._revlist(not_rev(revid), pub)</span><br><span class="line">    <span class="keyword">if</span> not_merged:</span><br><span class="line">      <span class="keyword">if</span> upstream_gain:</span><br><span class="line">        <span class="comment"># The user has published this branch and some of those</span></span><br><span class="line">        <span class="comment"># commits are not yet merged upstream.  We do not want</span></span><br><span class="line">        <span class="comment"># to rewrite the published commits so we punt.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        syncbuf.fail(self,</span><br><span class="line">                     <span class="string">"branch %s is published (but not merged) and is now "</span></span><br><span class="line">                     <span class="string">"%d commits behind"</span> % (branch.name, len(upstream_gain)))</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">elif</span> pub == head:</span><br><span class="line">      <span class="comment"># All published commits are merged, and thus we are a</span></span><br><span class="line">      <span class="comment"># strict subset.  We can fast-forward safely.</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      syncbuf.later1(self, _doff)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Examine the local commits not in the remote.  Find the</span></span><br><span class="line">  <span class="comment"># last one attributed to this user, if any.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  local_changes = self._revlist(not_rev(revid), HEAD, format=<span class="string">'%H %ce'</span>)</span><br><span class="line">  last_mine = <span class="literal">None</span></span><br><span class="line">  cnt_mine = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> commit <span class="keyword">in</span> local_changes:</span><br><span class="line">    commit_id, committer_email = commit.decode(<span class="string">'utf-8'</span>).split(<span class="string">' '</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> committer_email == self.UserEmail:</span><br><span class="line">      last_mine = commit_id</span><br><span class="line">      cnt_mine += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> upstream_gain <span class="keyword">and</span> cnt_mine == len(local_changes):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> self.IsDirty(consider_untracked=<span class="literal">False</span>):</span><br><span class="line">    syncbuf.fail(self, _DirtyError())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If the upstream switched on us, warn the user.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="keyword">if</span> branch.merge != self.revisionExpr:</span><br><span class="line">    <span class="keyword">if</span> branch.merge <span class="keyword">and</span> self.revisionExpr:</span><br><span class="line">      syncbuf.info(self,</span><br><span class="line">                   <span class="string">'manifest switched %s...%s'</span>,</span><br><span class="line">                   branch.merge,</span><br><span class="line">                   self.revisionExpr)</span><br><span class="line">    <span class="keyword">elif</span> branch.merge:</span><br><span class="line">      syncbuf.info(self,</span><br><span class="line">                   <span class="string">'manifest no longer tracks %s'</span>,</span><br><span class="line">                   branch.merge)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> cnt_mine &lt; len(local_changes):</span><br><span class="line">    <span class="comment"># Upstream rebased.  Not everything in HEAD</span></span><br><span class="line">    <span class="comment"># was created by this user.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    syncbuf.info(self,</span><br><span class="line">                 <span class="string">"discarding %d commits removed from upstream"</span>,</span><br><span class="line">                 len(local_changes) - cnt_mine)</span><br><span class="line"></span><br><span class="line">  branch.remote = self.GetRemote(self.remote.name)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> ID_RE.match(self.revisionExpr):</span><br><span class="line">    <span class="comment"># in case of manifest sync the revisionExpr might be a SHA1</span></span><br><span class="line">    branch.merge = self.revisionExpr</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> branch.merge.startswith(<span class="string">'refs/'</span>):</span><br><span class="line">      branch.merge = R_HEADS + branch.merge</span><br><span class="line">  branch.Save()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> cnt_mine &gt; <span class="number">0</span> <span class="keyword">and</span> self.rebase:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dorebase</span><span class="params">()</span>:</span></span><br><span class="line">      self._Rebase(upstream=<span class="string">'%s^1'</span> % last_mine, onto=revid)</span><br><span class="line">      self._CopyAndLinkFiles()</span><br><span class="line">    syncbuf.later2(self, _dorebase)</span><br><span class="line">  <span class="keyword">elif</span> local_changes:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self._ResetHard(revid)</span><br><span class="line">      self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">except</span> GitError <span class="keyword">as</span> e:</span><br><span class="line">      syncbuf.fail(self, e)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    syncbuf.later1(self, _doff)</span><br></pre></td></tr></table></figure>
<p>该函数不需要网络，仅是将前面获取到的更新合入本地工作区。该函数会比较当已检出的引用与仓库的引用的，确认本地仓库比远程仓库超前还是落后，如果远程仓库的引用本地没有，则使用<code>rebase</code>方式更新本地引用并合并到工作区。</p>
<h2 id="Init类的-LinkManifest函数" class="article-heading"><a href="#Init类的-LinkManifest函数" class="headerlink" title="Init类的_LinkManifest函数"></a>Init类的_LinkManifest函数<a class="article-anchor" href="#Init类的-LinkManifest函数" aria-hidden="true"></a></h2><p>_LinkManifest函数比较简单，仅仅使用<code>-m</code>参数传入的或默认的文件名创建一个链接。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_LinkManifest</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">      print(<span class="string">'fatal: manifest name (-m) is required.'</span>, file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self.manifest.Link(name)</span><br><span class="line">    <span class="keyword">except</span> ManifestParseError <span class="keyword">as</span> e:</span><br><span class="line">      print(<span class="string">"fatal: manifest '%s' not available"</span> % name, file=sys.stderr)</span><br><span class="line">      print(<span class="string">'fatal: %s'</span> % str(e), file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>至此<code>repo init</code>就结束了它的工作。然后即可使用<code>repo sync</code>同步所有项目。</p>
<h1 id="REPO-SYNC" class="article-heading"><a href="#REPO-SYNC" class="headerlink" title="REPO SYNC"></a>REPO SYNC<a class="article-anchor" href="#REPO-SYNC" aria-hidden="true"></a></h1><p>下面来看<code>sync</code>命令的<code>Execute</code>函数。该函数第一次运行时要根据 manifest 文件下载所有项目，之后再运行则同步所有项目到最新，所以该子命令比较复杂，但这里使用的大部分函数前面都用到过。</p>
<h2 id="sync命令的Execute函数实现" class="article-heading"><a href="#sync命令的Execute函数实现" class="headerlink" title="sync命令的Execute函数实现"></a>sync命令的Execute函数实现<a class="article-anchor" href="#sync命令的Execute函数实现" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  rp = self.manifest.repoProject</span><br><span class="line">  rp.PreSync()</span><br><span class="line"></span><br><span class="line">  mp = self.manifest.manifestProject</span><br><span class="line">  mp.PreSync()</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> opt.local_only:</span><br><span class="line">    mp.Sync_NetworkHalf(quiet=opt.quiet,</span><br><span class="line">                        current_branch_only=opt.current_branch_only,</span><br><span class="line">                        no_tags=opt.no_tags,</span><br><span class="line">                        optimized_fetch=opt.optimized_fetch)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  all_projects = self.GetProjects(args,</span><br><span class="line">                                  missing_ok=<span class="literal">True</span>,</span><br><span class="line">                                  submodules_ok=opt.fetch_submodules)</span><br><span class="line"></span><br><span class="line">  self._fetch_times = _FetchTimes(self.manifest)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> opt.local_only:</span><br><span class="line">    to_fetch = []</span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="keyword">if</span> _ONE_DAY_S &lt;= (now - rp.LastFetch):</span><br><span class="line">      to_fetch.append(rp)</span><br><span class="line">    to_fetch.extend(all_projects)</span><br><span class="line">    to_fetch.sort(key=self._fetch_times.Get, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    fetched = self._Fetch(to_fetch, opt)</span><br><span class="line">    _PostRepoFetch(rp, opt.no_repo_verify)</span><br><span class="line">    <span class="keyword">if</span> opt.network_only:</span><br><span class="line">      <span class="comment"># bail out now; the rest touches the working tree</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Iteratively fetch missing and/or nested unregistered submodules</span></span><br><span class="line">    previously_missing_set = set()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      self._ReloadManifest(manifest_name)</span><br><span class="line">      all_projects = self.GetProjects(args,</span><br><span class="line">                                      missing_ok=<span class="literal">True</span>,</span><br><span class="line">                                      submodules_ok=opt.fetch_submodules)</span><br><span class="line">      missing = []</span><br><span class="line">      <span class="keyword">for</span> project <span class="keyword">in</span> all_projects:</span><br><span class="line">        <span class="keyword">if</span> project.gitdir <span class="keyword">not</span> <span class="keyword">in</span> fetched:</span><br><span class="line">          missing.append(project)</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> missing:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="comment"># Stop us from non-stopped fetching actually-missing repos: If set of</span></span><br><span class="line">      <span class="comment"># missing repos has not been changed from last fetch, we break.</span></span><br><span class="line">      missing_set = set(p.name <span class="keyword">for</span> p <span class="keyword">in</span> missing)</span><br><span class="line">      <span class="keyword">if</span> previously_missing_set == missing_set:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      previously_missing_set = missing_set</span><br><span class="line">      fetched.update(self._Fetch(missing, opt))</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  syncbuf = SyncBuffer(mp.config,</span><br><span class="line">                        detach_head = opt.detach_head)</span><br><span class="line">  pm = Progress(<span class="string">'Syncing work tree'</span>, len(all_projects))</span><br><span class="line">  <span class="keyword">for</span> project <span class="keyword">in</span> all_projects:</span><br><span class="line">    pm.update()</span><br><span class="line">    <span class="keyword">if</span> project.worktree:</span><br><span class="line">      project.Sync_LocalHalf(syncbuf, force_sync=opt.force_sync)</span><br><span class="line">  pm.end()</span><br><span class="line">  print(file=sys.stderr)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> syncbuf.Finish():</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># If there's a notice that's supposed to print at the end of the sync, print</span></span><br><span class="line">  <span class="comment"># it now...</span></span><br><span class="line">  <span class="keyword">if</span> self.manifest.notice:</span><br><span class="line">    print(self.manifest.notice)</span><br></pre></td></tr></table></figure>
<p>首先取得<code>repoProject</code>和<code>manifestProject</code>两个对象，对这两个对象调用<code>PreSync</code>函数获取当前分支跟踪的远程分支负给<code>revisionExpr</code>，后续的<code>Sync_NetworkHalf</code>会使用该值来决定是否需要从远程仓库更新对象。前面已经讲过<code>Sync_NetworkHalf</code>函数，它使用<code>_InitGitDir</code>函数（如果仓库不存大）创建仓库目录并下载对象数据，或使用<code>_UpdateHooks</code>函数(仓库存在)创建<code>commit-msg -&gt; ../../repo/hooks/commit-msg</code>，<code>pre-auto-gc -&gt; ../../repo/hooks/pre-auto-gc</code>两个软链接链接向repo仓库下面hooks目录下的对应文件。该勾子脚本对Repo与Gerrit的协作起着至关重要的作用。这里之所以针对<code>manifestProject</code>对象再调用一次主要是为了防止清单库有更新，如果有更新，在同步项目时确保同步的是最新的清单文件指定的项目。</p>
<p>然后从清单文件获取所有的项目列表，使用<code>_Fetch</code>函数获取项目全部（第一次）或更新的对象文件到对应的远程分支上，并对照清单文件做一个检查，如果有未下载的再下载一次。之后为每个项目创建一个线程，在线程内部使用<code>Sync_LocalHalf</code>函数<code>rebase</code>到工作区。</p>
<p><code>Sync_LocalHalf</code>函数主要通过<code>git rebase</code>命令来完成工作，主要有以下几种情况：</p>
<ul>
<li>如果工作区当前处理分离头指针状态：直接检出最新的引用ID。</li>
<li>如果工作区当前处理本地分支上：直接检出最新的引用ID，使其处理分离头指针状态。</li>
<li>如果工作区当前处理本地远程跟踪分支上：如果工作区有未推送的提交则执行<code>git rebase</code>合并。</li>
</ul>
<h1 id="REPO-START" class="article-heading"><a href="#REPO-START" class="headerlink" title="REPO START"></a>REPO START<a class="article-anchor" href="#REPO-START" aria-hidden="true"></a></h1><p>下面来看<code>start</code>命令的<code>Execute</code>函数。</p>
<h2 id="start命令的Execute函数实现" class="article-heading"><a href="#start命令的Execute函数实现" class="headerlink" title="start命令的Execute函数实现"></a>start命令的Execute函数实现<a class="article-anchor" href="#start命令的Execute函数实现" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span><span class="params">(Command)</span>:</span></span><br><span class="line">  common = <span class="literal">True</span></span><br><span class="line">  helpSummary = <span class="string">"Start a new branch for development"</span></span><br><span class="line">  helpUsage = <span class="string">"""</span></span><br><span class="line"><span class="string">%prog &lt;newbranchname&gt; [--all | &lt;project&gt;...]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">  helpDescription = <span class="string">"""</span></span><br><span class="line"><span class="string">'%prog' begins a new branch of development, starting from the</span></span><br><span class="line"><span class="string">revision specified in the manifest.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_Options</span><span class="params">(self, p)</span>:</span></span><br><span class="line">    p.add_option(<span class="string">'--all'</span>,</span><br><span class="line">                 dest=<span class="string">'all'</span>, action=<span class="string">'store_true'</span>,</span><br><span class="line">                 help=<span class="string">'begin branch in all projects'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args:</span><br><span class="line">      self.Usage()</span><br><span class="line"></span><br><span class="line">    nb = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> git.check_ref_format(<span class="string">'heads/%s'</span> % nb):</span><br><span class="line">      print(<span class="string">"error: '%s' is not a valid name"</span> % nb, file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    err = []</span><br><span class="line">    projects = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> opt.all:</span><br><span class="line">      projects = args[<span class="number">1</span>:]</span><br><span class="line">      <span class="keyword">if</span> len(projects) &lt; <span class="number">1</span>:</span><br><span class="line">        projects = [<span class="string">'.'</span>,]  <span class="comment"># start it in the local project by default</span></span><br><span class="line"></span><br><span class="line">    all_projects = self.GetProjects(projects,</span><br><span class="line">                                    missing_ok=bool(self.gitc_manifest))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This must happen after we find all_projects, since GetProjects may need</span></span><br><span class="line">    <span class="comment"># the local directory, which will disappear once we save the GITC manifest.</span></span><br><span class="line">    <span class="keyword">if</span> self.gitc_manifest:</span><br><span class="line">      gitc_projects = self.GetProjects(projects, manifest=self.gitc_manifest,</span><br><span class="line">                                       missing_ok=<span class="literal">True</span>)</span><br><span class="line">      <span class="keyword">for</span> project <span class="keyword">in</span> gitc_projects:</span><br><span class="line">        <span class="keyword">if</span> project.old_revision:</span><br><span class="line">          project.already_synced = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          project.already_synced = <span class="literal">False</span></span><br><span class="line">          project.old_revision = project.revisionExpr</span><br><span class="line">        project.revisionExpr = <span class="literal">None</span></span><br><span class="line">      <span class="comment"># Save the GITC manifest.</span></span><br><span class="line">      gitc_utils.save_manifest(self.gitc_manifest)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Make sure we have a valid CWD</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.getcwd()):</span><br><span class="line">        os.chdir(self.manifest.topdir)</span><br><span class="line"></span><br><span class="line">    pm = Progress(<span class="string">'Starting %s'</span> % nb, len(all_projects))</span><br><span class="line">    <span class="keyword">for</span> project <span class="keyword">in</span> all_projects:</span><br><span class="line">      pm.update()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.gitc_manifest:</span><br><span class="line">        gitc_project = self.gitc_manifest.paths[project.relpath]</span><br><span class="line">        <span class="comment"># Sync projects that have not been opened.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> gitc_project.already_synced:</span><br><span class="line">          proj_localdir = os.path.join(self.gitc_manifest.gitc_client_dir,</span><br><span class="line">                                       project.relpath)</span><br><span class="line">          project.worktree = proj_localdir</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(proj_localdir):</span><br><span class="line">            os.makedirs(proj_localdir)</span><br><span class="line">          project.Sync_NetworkHalf()</span><br><span class="line">          sync_buf = SyncBuffer(self.manifest.manifestProject.config)</span><br><span class="line">          project.Sync_LocalHalf(sync_buf)</span><br><span class="line">          project.revisionId = gitc_project.old_revision</span><br><span class="line"></span><br><span class="line">      <span class="comment"># If the current revision is a specific SHA1 then we can't push back</span></span><br><span class="line">      <span class="comment"># to it; so substitute with dest_branch if defined, or with manifest</span></span><br><span class="line">      <span class="comment"># default revision instead.</span></span><br><span class="line">      branch_merge = <span class="string">''</span></span><br><span class="line">      <span class="keyword">if</span> IsId(project.revisionExpr):</span><br><span class="line">        <span class="keyword">if</span> project.dest_branch:</span><br><span class="line">          branch_merge = project.dest_branch</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          branch_merge = self.manifest.default.revisionExpr</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> project.StartBranch(nb, branch_merge=branch_merge):</span><br><span class="line">        err.append(project)</span><br><span class="line">    pm.end()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err:</span><br><span class="line">      <span class="keyword">for</span> p <span class="keyword">in</span> err:</span><br><span class="line">        print(<span class="string">"error: %s/: cannot start %s"</span> % (p.relpath, nb),</span><br><span class="line">              file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从源代码中也可以看到<code>start</code>命令的使用方法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo start &lt;newbranchname&gt; [--all | &lt;project&gt;...]</span><br></pre></td></tr></table></figure></p>
<p>如果没有提供<code>--all</code>参数，则取后面指定的<code>&lt;project&gt;</code>列表作为操作对象，如果<code>&lt;project&gt;</code>为空，则取当前目录所在的项目作为操作项目。</p>
<p>为每一个项目创建一个线程来处理。该线程首先检查当前分支所处的状态，如果处于“分离头指针”（即处于具体的 SHA1 上）状态，则判断是否定义默认的codereview分支（<code>dest_branch</code>默认codereview分支由清单文件的<code>dest-branch</code>属性指定），如果有则使用清单文件指定的默认的codereview分支作为<code>branch_merge</code>的值，如果没有则使用manifest.xml中指定的关于该项目的revision属性作为<code>branch_merge</code>的值。接下来使用新的分支名<code>&lt;newbranchname&gt;</code>和<code>branch_merge</code>作参数调用<code>project</code>类的<code>StartBranch</code>创建新分支。</p>
<p>如果项目刚同步下来第一次调用<code>repo start</code>此时项目处理分离头指针状态，且默认的manifest文件没有指定<code>dest-branch</code>属性，所以<code>dest_branch</code>取manifest.xml中关于该项目的<code>revision</code>属性。如果项目已处理某个分支之上，则<code>dest_branch</code>为空。后面会看到如果入参<code>dest_branch</code>为空，会取项目当前所处的分支。</p>
<h2 id="project类的StartBranch函数" class="article-heading"><a href="#project类的StartBranch函数" class="headerlink" title="project类的StartBranch函数"></a>project类的StartBranch函数<a class="article-anchor" href="#project类的StartBranch函数" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StartBranch</span><span class="params">(self, name, branch_merge=<span class="string">''</span>)</span>:</span></span><br><span class="line">  <span class="string">"""Create a new branch off the manifest's revision.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> branch_merge:</span><br><span class="line">    branch_merge = self.revisionExpr</span><br><span class="line">  head = self.work_git.GetHead()</span><br><span class="line">  <span class="keyword">if</span> head == (R_HEADS + name):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  all_refs = self.bare_ref.all</span><br><span class="line">  <span class="keyword">if</span> R_HEADS + name <span class="keyword">in</span> all_refs:</span><br><span class="line">    <span class="keyword">return</span> GitCommand(self,</span><br><span class="line">                      [<span class="string">'checkout'</span>, name, <span class="string">'--'</span>],</span><br><span class="line">                      capture_stdout=<span class="literal">True</span>,</span><br><span class="line">                      capture_stderr=<span class="literal">True</span>).Wait() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  branch = self.GetBranch(name)</span><br><span class="line">  branch.remote = self.GetRemote(self.remote.name)</span><br><span class="line">  branch.merge = branch_merge</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> branch.merge.startswith(<span class="string">'refs/'</span>) <span class="keyword">and</span> <span class="keyword">not</span> ID_RE.match(branch_merge):</span><br><span class="line">    branch.merge = R_HEADS + branch_merge</span><br><span class="line">  revid = self.GetRevisionId(all_refs)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> head.startswith(R_HEADS):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      head = all_refs[head]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">      head = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">if</span> revid <span class="keyword">and</span> head <span class="keyword">and</span> revid == head:</span><br><span class="line">    ref = os.path.join(self.gitdir, R_HEADS + name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      os.makedirs(os.path.dirname(ref))</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    _lwrite(ref, <span class="string">'%s\n'</span> % revid)</span><br><span class="line">    _lwrite(os.path.join(self.worktree, <span class="string">'.git'</span>, HEAD),</span><br><span class="line">            <span class="string">'ref: %s%s\n'</span> % (R_HEADS, name))</span><br><span class="line">    branch.Save()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> GitCommand(self,</span><br><span class="line">                [<span class="string">'checkout'</span>, <span class="string">'-b'</span>, branch.name, revid],</span><br><span class="line">                capture_stdout=<span class="literal">True</span>,</span><br><span class="line">                capture_stderr=<span class="literal">True</span>).Wait() == <span class="number">0</span>:</span><br><span class="line">    branch.Save()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>在project.py文件的<code>project</code>类中<code>StartBranch</code>以及之后的<code>CheckoutBranch</code>、<code>AbandonBranch</code>、<code>PruneHeads</code>几个函数主要是用作分支管理的。后续的<code>repo checkout</code>、<code>repo abandon</code>、<code>repo prune</code>就是使用它们来完成工作的。在这里只分支<code>StartBranch</code>函数，其它的函数后续遇到的时候再分析。</p>
<p>检查当前分支是不是要创建的分支，如果是就什么也不做，如果不是再检查要创建的分支是否已存在，如果存在就检出该分支。</p>
<h1 id="REPO-UPLOAD" class="article-heading"><a href="#REPO-UPLOAD" class="headerlink" title="REPO UPLOAD"></a>REPO UPLOAD<a class="article-anchor" href="#REPO-UPLOAD" aria-hidden="true"></a></h1><p>在执行upload时，如果指定了项目则从指定项目中查找，如果没有指定则遍历所有项目。</p>
<p>Repo工具为每一个项目添加一个<code>refs/published/&lt;branch_name&gt;</code>引用文件来记录该分支的最新upload引用。</p>
<p>对于一个项目的所有topic分支，获取未upload的变更的过程如下：</p>
<ol>
<li>首行比较它的<code>refs/heads/&lt;branch_name&gt;</code>与对应的<code>refs/published/&lt;branch_name&gt;</code>，如果两个引用的ref_id相同，就认为所有提交都已提交Review。</li>
<li>否则就获取该分支的未推送变更，如果没有未推送变更，则认为所有提交都已提交Review。</li>
<li>否则就列出未推送的变更等待upload。</li>
</ol>
<h2 id="Review路径的获取" class="article-heading"><a href="#Review路径的获取" class="headerlink" title="Review路径的获取"></a>Review路径的获取<a class="article-anchor" href="#Review路径的获取" aria-hidden="true"></a></h2><p>默认情况下Repo要与Gerrit通过两次网络交互才能将变更推送上去，第一个只通过http协议获取一个推送的地址。</p>
<p>Repo会向manifest文件中review属性指定的url发送一个地址为<code>http://$url/ssh_info</code>的http请求，Gerrit会返回提交变更使用的真正ssh地址及端口号。默认的端口号为29418。</p>
<h2 id="推送变更到Gerrit" class="article-heading"><a href="#推送变更到Gerrit" class="headerlink" title="推送变更到Gerrit"></a>推送变更到Gerrit<a class="article-anchor" href="#推送变更到Gerrit" aria-hidden="true"></a></h2><p>Repo使用以下命令格式推送变更：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --receive-pack=<span class="string">'gerrit receive-pack --reviewer=&lt;reviewer_email&gt; --cc=&lt;cc_user_email&gt;'</span> \</span><br><span class="line">         ssh://username@&#123;前面http请求返回的url地址&#125;:&#123;前面返回的端口号&#125;/&lt;project_name&gt; &lt;review_branch&gt;:refs/<span class="keyword">for</span>/&lt;dest_branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>把变更推送到Gerrit后，Repo会更新本地topic分支的<code>refs/published/&lt;branch_name&gt;</code>引用。</p>
<p>其实我们也可以使用手动的方式来推送变更到Gerrit，但是不能自动更新pushlished下的引用，因此再使用<code>repo upload</code>命令时会发现变更会再次让你upload，但其实他们已经推送到Gerrit了，你必须手动更新<code>refs/published/&lt;branch_name&gt;</code>到你的HEAD。</p>

              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2019-04-03T08:13:36.966Z" itemprop="dateModified">上次更新：2019-04-03</time>
                <a href="/2013/08/07/cmake-usage/" class="article-footer-prev" title="CMAKE使用"><i class="fa fa-chevron-left"></i><span>上一页</span></a>
              </footer>
              
<section id="comments">
  <div id="disqus_thread"></div>
</section>
<script>
  var disqus_shortname = 'antsir';
  var disqus_url = 'https://ant-sir.xyz/2013/07/03/google-repo/index.html';
  var disqus_title = "Google Repo";
  var disqus_config = function(){
    this.language = 'zh';
  };
  (function(){
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'https://go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#从Android说起"><span class="toc-text">从Android说起</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AOSP的组成"><span class="toc-text">AOSP的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repo库"><span class="toc-text">repo库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#manifest库"><span class="toc-text">manifest库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装Repo"><span class="toc-text">安装Repo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化Repo客户端"><span class="toc-text">初始化Repo客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下载Android源码树"><span class="toc-text">下载Android源码树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络问题"><span class="toc-text">网络问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#制作地本镜像库"><span class="toc-text">制作地本镜像库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#校验Git-Tags"><span class="toc-text">校验Git Tags</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO的使用"><span class="toc-text">REPO的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#help"><span class="toc-text">help</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-text">init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync"><span class="toc-text">sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#start"><span class="toc-text">start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#status"><span class="toc-text">status</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checkout"><span class="toc-text">checkout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#branches"><span class="toc-text">branches</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff"><span class="toc-text">diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stage"><span class="toc-text">stage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#upload"><span class="toc-text">upload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#download"><span class="toc-text">download</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rebase"><span class="toc-text">rebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prune"><span class="toc-text">prune</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abandon"><span class="toc-text">abandon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forall"><span class="toc-text">forall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#version"><span class="toc-text">version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-text">list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selfupdate"><span class="toc-text">selfupdate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#manifest"><span class="toc-text">manifest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#官网的cheatsheet"><span class="toc-text">官网的cheatsheet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repo工作流"><span class="toc-text">Repo工作流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO的引导文件"><span class="toc-text">REPO的引导文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#入口"><span class="toc-text">入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main函数"><span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整的Repo库"><span class="toc-text">完整的Repo库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用bundle文件"><span class="toc-text">使用bundle文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用代理"><span class="toc-text">使用代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repo仓库地址"><span class="toc-text">Repo仓库地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真正的checkout"><span class="toc-text">真正的checkout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用main-py"><span class="toc-text">调用main.py</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#main-py"><span class="toc-text">main.py</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#导入all-commands"><span class="toc-text">导入all_commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main函数"><span class="toc-text">_Main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repo类"><span class="toc-text">_Repo类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XmlManifest类"><span class="toc-text">XmlManifest类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MetaProject类"><span class="toc-text">MetaProject类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类的init函数"><span class="toc-text">Project类的init函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程仓库的路径"><span class="toc-text">远程仓库的路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-INIT"><span class="toc-text">REPO INIT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Init类的Execute函数"><span class="toc-text">Init类的Execute函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Init类的-SyncManifest函数"><span class="toc-text">Init类的_SyncManifest函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类图"><span class="toc-text">Project类图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类的Sync-NetworkHalf函数"><span class="toc-text">Project类的Sync_NetworkHalf函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类的-InitGitDir函数"><span class="toc-text">Project类的_InitGitDir函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplyCloneBundle函数实现"><span class="toc-text">_ApplyCloneBundle函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sync-LocalHalf函数实现"><span class="toc-text">Sync_LocalHalf函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Init类的-LinkManifest函数"><span class="toc-text">Init类的_LinkManifest函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-SYNC"><span class="toc-text">REPO SYNC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sync命令的Execute函数实现"><span class="toc-text">sync命令的Execute函数实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-START"><span class="toc-text">REPO START</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#start命令的Execute函数实现"><span class="toc-text">start命令的Execute函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project类的StartBranch函数"><span class="toc-text">project类的StartBranch函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-UPLOAD"><span class="toc-text">REPO UPLOAD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Review路径的获取"><span class="toc-text">Review路径的获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推送变更到Gerrit"><span class="toc-text">推送变更到Gerrit</span></a></li></ol></li></ol>
              <a href="#" id="article-toc-top">回到顶部</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">欢迎</strong><a href="/categories" class="sidebar-link">欢迎</a><strong class="sidebar-title">学习笔记</strong><a href="/2014/01/07/learn-python/" class="sidebar-link">Python笔记</a><strong class="sidebar-title">工具使用</strong><a href="/2013/05/05/learn-git/" class="sidebar-link">Git学习笔记</a><a href="/2013/08/07/cmake-usage/" class="sidebar-link">CMAKE使用</a><a href="/2013/07/03/google-repo/" class="sidebar-link current">Google Repo</a>
    <strong class="sidebar-title">PYTHON</strong><a href="/2014/01/07/learn-python/" class="sidebar-link">Python笔记</a><strong class="sidebar-title">GIT</strong><a href="/2013/05/05/learn-git/" class="sidebar-link">Git学习笔记</a><strong class="sidebar-title">CMAKE</strong><a href="/2013/08/07/cmake-usage/" class="sidebar-link">CMAKE使用</a><strong class="sidebar-title">REPO</strong><a href="/2013/07/03/google-repo/" class="sidebar-link current">Google Repo</a>
 </div>
</aside>

    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2019 <a href="https://ant-sir.xyz" target="_blank">Zhu Yanlei</a><br>
      Documentation licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>.
    </div>
    <div id="footer-links">
      <a href="https://weibo.com/5301170870" class="footer-link" target="_blank"><i class="fa fa-weibo"></i></a>
      <a href="https://github.com/ant-sir/site" class="footer-link" target="_blank"> <i class="fa fa-weixin" aria-hidden="true"></i></a>
      <a href="https://github.com/ant-sir/site" class="footer-link" target="_blank"> <i class="fa fa-qq" aria-hidden="true"></i></a>
      <a href="https://github.com/ant-sir/site" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/" class="mobile-nav-link">主页</a><a href="/categories/" class="mobile-nav-link">分类</a><a href="/archives/" class="mobile-nav-link">归档</a><a href="/about/" class="mobile-nav-link">关于</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/ant-sir/site" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">欢迎</strong><a href="/categories" class="mobile-nav-link">欢迎</a><strong class="mobile-nav-title">学习笔记</strong><a href="/2014/01/07/learn-python/" class="mobile-nav-link">Python笔记</a><strong class="mobile-nav-title">工具使用</strong><a href="/2013/05/05/learn-git/" class="mobile-nav-link">Git学习笔记</a><a href="/2013/08/07/cmake-usage/" class="mobile-nav-link">CMAKE使用</a><a href="/2013/07/03/google-repo/" class="mobile-nav-link current">Google Repo</a>
      <strong class="mobile-nav-title">PYTHON</strong><a href="/2014/01/07/learn-python/" class="mobile-nav-link">Python笔记</a><strong class="mobile-nav-title">GIT</strong><a href="/2013/05/05/learn-git/" class="mobile-nav-link">Git学习笔记</a><strong class="mobile-nav-title">CMAKE</strong><a href="/2013/08/07/cmake-usage/" class="mobile-nav-link">CMAKE使用</a><strong class="mobile-nav-title">REPO</strong><a href="/2013/07/03/google-repo/" class="mobile-nav-link current">Google Repo</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></span>
    <select id="mobile-lang-select" data-canonical="">
      
        <option value="zh-cn" selected>简体中文</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- Cookie -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.0/js.cookie.min.js"></script>
<!-- build:js build/js/main.js -->
<script src="/js/lang_select.js"></script>
<script src="/js/toc.js"></script>
<script src="/js/mobile_nav.js"></script>
<!-- endbuild -->
<!-- Algolia -->

<script>document.getElementById('search-input-wrap').classList.add('on');</script>
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
  docsearch({
    // Your apiKey and indexName will be given to you once
    // we create your config
    apiKey: '36fb45dc14ef77aa8bdf5b2dbf75c87f',
    indexName: 'hexo-search',
    appId: 'IKDE0Z5WJI', // Should be only included if you are running DocSearch on your own.
    // Replace inputSelector with a CSS selector
    // matching your search input
    inputSelector: '#search-input',
    // Set debug to true if you want to inspect the dropdown
    debug: false,
  });
</script>


</body>
</html>
