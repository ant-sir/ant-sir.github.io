<!DOCTYPE html>
<html lang="zh-cn">
<head prefix="og: https://ogp.me/ns#"><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>repo实现学习笔记 | Ant-Home</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://ant-sir.xyz/20134/02/03/repo-source/index.html">
  
  <!-- Alternative links -->
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/icon/mstile-144x144.png">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  <link rel="stylesheet" href="/css/navy.css">
  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css">
  <!-- Google Analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61377615-1', 'auto');
  ga('send', 'pageview');
</script>

  <!-- Baidu auto push -->
  <script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
</head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/" id="logo">Hexo</a>
    </h1>
    <nav id="main-nav">
      <a href="/" class="main-nav-link">主页</a><a href="/categories/" class="main-nav-link">分类</a><a href="/archives/" class="main-nav-link">归档</a><a href="/about/" class="main-nav-link">关于</a>
      <a href="https://github.com/ant-sir/site" class="main-nav-link"><i class="fa fa-github-alt"></i></a>
      <div id="search-input-wrap">
        <div id="search-input-icon">
          <i class="fa fa-search"></i>
        </div>
        <input type="search" id="search-input" placeholder="Search...">
      </div>
    </nav>
    <div id="lang-select-wrap">
      <label id="lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></label>
      <select id="lang-select" data-canonical="">
        
          <option value="zh-cn" selected>简体中文</option>
        
      </select>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="https://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">repo实现学习笔记</h1>
                <a href="https://github.com/ant-sir/site/edit/master/source/_posts/2014-02-03-repo-source.md" class="article-edit-link" title="改进本文"><i class="fa fa-pencil"></i></a>
              </header>
              <div class="article-content" itemprop="articleBody">
                <p>通过分析repo的源码实现，更好的了解工具的操作，以及对自己实际项目的针对性修改。<br><a id="more"></a></p>
<h1 id="REPO的引导文件" class="article-heading"><a href="#REPO的引导文件" class="headerlink" title="REPO的引导文件"></a>REPO的引导文件<a class="article-anchor" href="#REPO的引导文件" aria-hidden="true"></a></h1><p>前面提到通过<code>curl</code>下载的Repo文件仅仅是一个引导脚本（bootstrap），Repo引导脚本的主要工作：</p>
<ul>
<li>加载完整的Repo工具库到当前目录下的<code>.repo/repo</code>目录下。</li>
<li>启动并将控制权交给工作区的<code>.repo/repo/main.py</code>这个刚刚从<code>repo.git</code>库克隆来的脚本文件。</li>
<li>之后在<code>main.py</code>文件中克隆Android的清单库<code>manifest.git</code>（这已经不是引导脚本的工作了）。</li>
</ul>
<p>Repo引导文件所做的事情非常简单，如果第一次执行，下载完整的Repo仓库，之后把工作交给main.py。如果不是第一次执行，则直接把工作交给main.py去执行。</p>
<p>阅读Repo引导文件可以从中获取一些有用的信息，下面对Repo启动脚本作一个分析：</p>
<h2 id="入口" class="article-heading"><a href="#入口" class="headerlink" title="入口"></a>入口<a class="article-anchor" href="#入口" aria-hidden="true"></a></h2><p>repo脚本主入口函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p>
<p>调用main函数，参数为<code>init -u https://android.googlesource.com/platform/manifest</code></p>
<h2 id="main函数" class="article-heading"><a href="#main函数" class="headerlink" title="main函数"></a>main函数<a class="article-anchor" href="#main函数" aria-hidden="true"></a></h2><p><code>main</code>函数实现如下（删除了一些无关的信息）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(orig_args)</span>:</span></span><br><span class="line">  repo_main, rel_repo_dir = _FindRepo()</span><br><span class="line">  cmd, opt, args = _ParseArguments(orig_args)</span><br><span class="line"></span><br><span class="line">  wrapper_path = os.path.abspath(__file__)</span><br><span class="line">  my_main, my_git = _RunSelf(wrapper_path)</span><br><span class="line"></span><br><span class="line">  cwd = os.getcwd()</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> repo_main:</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'init'</span> <span class="keyword">or</span> cmd == <span class="string">'gitc-init'</span>:</span><br><span class="line">      <span class="keyword">if</span> my_git:</span><br><span class="line">        _SetDefaultsTo(my_git)</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        _Init(args, gitc_init=(cmd == <span class="string">'gitc-init'</span>))</span><br><span class="line">      <span class="keyword">except</span> CloneFailure:</span><br><span class="line">        shutil.rmtree(os.path.join(repodir, S_repo), ignore_errors=<span class="literal">True</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">      repo_main, rel_repo_dir = _FindRepo()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      _NoCommands(cmd)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> my_main:</span><br><span class="line">    repo_main = my_main</span><br><span class="line"></span><br><span class="line">  ver_str = <span class="string">'.'</span>.join(map(str, VERSION))</span><br><span class="line">  me = [sys.executable, repo_main,</span><br><span class="line">        <span class="string">'--repo-dir=%s'</span> % rel_repo_dir,</span><br><span class="line">        <span class="string">'--wrapper-version=%s'</span> % ver_str,</span><br><span class="line">        <span class="string">'--wrapper-path=%s'</span> % wrapper_path,</span><br><span class="line">        <span class="string">'--'</span>]</span><br><span class="line">  me.extend(orig_args)</span><br><span class="line">  me.extend(extra_args)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    os.execv(sys.executable, me)</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    _print(<span class="string">"fatal: unable to start %s"</span> % repo_main, file=sys.stderr)</span><br><span class="line">    _print(<span class="string">"fatal: %s"</span> % e, file=sys.stderr)</span><br><span class="line">    sys.exit(<span class="number">148</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>main</code>函数首先查找完整的repo仓库是否存在（<code>_FindRepo()</code>函数），如果存在则使用<code>os.execv</code>调用<code>main.py</code>把控制权直接交给<code>main.py</code>。如果repo仓库不存在，则使用本地函数<code>_Init</code>创建目录并下载repo仓库。因为此时没有repo仓库，所以完整repo仓库的下载仅能使用Repo引导文件的内部函数，这与后续其它仓库的下载是不一样的。</p>
<h2 id="完整的Repo库" class="article-heading"><a href="#完整的Repo库" class="headerlink" title="完整的Repo库"></a>完整的Repo库<a class="article-anchor" href="#完整的Repo库" aria-hidden="true"></a></h2><p><code>_RunSelf</code>判断运行Repo脚本所在目录是否存在<code>main.py</code>和<code>.git</code>目录，如果存在就继续判断是否存在<code>git_config.py</code>，<code>project.py</code>，<code>subcmds</code>目录。从这段代码可以看出，一个完整的Repo仓库需要<code>main.py</code>，<code>.git</code>，<code>git_config.py</code>，<code>project.py</code>，<code>subcmds</code>这五部分组成。如果这些都存在，就认为本地存在完整的repo仓库。</p>
<h2 id="使用bundle文件" class="article-heading"><a href="#使用bundle文件" class="headerlink" title="使用bundle文件"></a>使用bundle文件<a class="article-anchor" href="#使用bundle文件" aria-hidden="true"></a></h2><p><code>_Init</code>函数内部使用了<code>_Clone</code>函数来克隆代码，实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Clone</span><span class="params">(url, local, quiet)</span>:</span></span><br><span class="line">  <span class="string">"""Clones a git repository to a new subdirectory of repodir</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    os.mkdir(local)</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    _print(<span class="string">'fatal: cannot make %s directory: %s'</span> % (local, e.strerror),</span><br><span class="line">           file=sys.stderr)</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br><span class="line"></span><br><span class="line">  cmd = [GIT, <span class="string">'init'</span>, <span class="string">'--quiet'</span>]</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    proc = subprocess.Popen(cmd, cwd = local)</span><br><span class="line">  <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  _InitHttp()</span><br><span class="line">  _SetConfig(local, <span class="string">'remote.origin.url'</span>, url)</span><br><span class="line">  _SetConfig(local, <span class="string">'remote.origin.fetch'</span>,</span><br><span class="line">                    <span class="string">'+refs/heads/*:refs/remotes/origin/*'</span>)</span><br><span class="line">  <span class="keyword">if</span> _DownloadBundle(url, local, quiet):</span><br><span class="line">    _ImportBundle(local)</span><br><span class="line">  _Fetch(url, local, <span class="string">'origin'</span>, quiet)</span><br></pre></td></tr></table></figure></p>
<p>为了加速下载，Google为每个仓库都提供了对应的bundle文件，下载时Repo时会先下载repo仓库的bundle文件，如果下载成功则从bundle文件中fetch出库，无论成功与否都会再次通过<code>git fetch</code>命令获取仓库。（<code>git fetch</code>可以直接从bundle文件提取出库。）</p>
<h2 id="使用代理" class="article-heading"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理<a class="article-anchor" href="#使用代理" aria-hidden="true"></a></h2><p>从<code>_InitHttp</code>函数可以看出，repo引导脚本支持两种代理方式：</p>
<ul>
<li>用户目录下的<code>.netrc</code>文件</li>
<li>直接在终端下指定<code>http_proxy</code>环境变量</li>
</ul>
<h2 id="Repo仓库地址" class="article-heading"><a href="#Repo仓库地址" class="headerlink" title="Repo仓库地址"></a>Repo仓库地址<a class="article-anchor" href="#Repo仓库地址" aria-hidden="true"></a></h2><p>Repo仓库的地下可以通过多种方式给出，一种是通过命令行参数<code>--repo-url=URL</code>，一种是通过环境变量<code>REPO_URL</code>给出，另一种是写死在引导文件代码里。当然，对应的分支亦可以通过这几种方法指定。</p>
<h2 id="真正的checkout" class="article-heading"><a href="#真正的checkout" class="headerlink" title="真正的checkout"></a>真正的checkout<a class="article-anchor" href="#真正的checkout" aria-hidden="true"></a></h2><p><code>_Checkout</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Checkout</span><span class="params">(cwd, branch, rev, quiet)</span>:</span></span><br><span class="line">  <span class="string">"""Checkout an upstream branch into the repository and track it.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  cmd = [GIT, <span class="string">'update-ref'</span>, <span class="string">'refs/heads/default'</span>, rev]</span><br><span class="line">  <span class="keyword">if</span> subprocess.Popen(cmd, cwd = cwd).wait() != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br><span class="line"></span><br><span class="line">  _SetConfig(cwd, <span class="string">'branch.default.remote'</span>, <span class="string">'origin'</span>)</span><br><span class="line">  _SetConfig(cwd, <span class="string">'branch.default.merge'</span>, <span class="string">'refs/heads/%s'</span> % branch)</span><br><span class="line"></span><br><span class="line">  cmd = [GIT, <span class="string">'symbolic-ref'</span>, <span class="string">'HEAD'</span>, <span class="string">'refs/heads/default'</span>]</span><br><span class="line">  <span class="keyword">if</span> subprocess.Popen(cmd, cwd = cwd).wait() != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br><span class="line"></span><br><span class="line">  cmd = [GIT, <span class="string">'read-tree'</span>, <span class="string">'--reset'</span>, <span class="string">'-u'</span>]</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> quiet:</span><br><span class="line">    cmd.append(<span class="string">'-v'</span>)</span><br><span class="line">  cmd.append(<span class="string">'HEAD'</span>)</span><br><span class="line">  <span class="keyword">if</span> subprocess.Popen(cmd, cwd = cwd).wait() != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> CloneFailure()</span><br></pre></td></tr></table></figure></p>
<p><code>_Checkout</code>函数先使用<code>git update-ref</code>把<code>refs/heads/default</code>指向为一个稳定的发布版本。然后使用<code>git symbolic-ref HEAD refs/heads/default</code>命令设置HEAD指针使其指向default分支。最后使用<code>git read-tree --reset -u HEAD</code>命令检出工作区，<code>git checkout</code>就是使用底层命令<code>read-tree</code>来实现功能的。</p>
<p>Repo仓库克隆完成之后位于工作区目标下的<code>.repo/repo</code>路径下，此时的<code>.repo</code>目标下只有Repo工具的仓库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zyl@localhost:.repo]$ ls -a</span><br><span class="line">.  ..  repo</span><br></pre></td></tr></table></figure></p>
<p>Repo仓库的分支情况如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* default</span><br><span class="line">  remotes/origin/maint</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/stable</span><br></pre></td></tr></table></figure></p>
<h2 id="调用main-py" class="article-heading"><a href="#调用main-py" class="headerlink" title="调用main.py"></a>调用main.py<a class="article-anchor" href="#调用main-py" aria-hidden="true"></a></h2><p>接下来把权限交给main.py，它会完成Repo仓库的另外一些操作以及manifests为的克隆。</p>
<h1 id="main-py" class="article-heading"><a href="#main-py" class="headerlink" title="main.py"></a>main.py<a class="article-anchor" href="#main-py" aria-hidden="true"></a></h1><p>main.py先从<code>subcmds</code>包导入<code>all_commands</code>列表，该列表由所有子命令对象组成，这些子命令在subcmds目录下，每个子命令对应一个模块文件，文件名就是子命令名，每一个文件都定义了以该文件名命令的类，该类实现了对应命令的功能。这些子命令类都是直接或间接从<code>Command</code>类继承。</p>
<p>下面来看一张子命令的类图：</p>
<p><a href="/img/class-command.png"><img src="/img/class-command.png" alt="command"></a></p>
<p>从图中可以清晰的看到子类”重载“基类的<code>Execute</code>函数以完成自己的工作。而基类的<code>Execute</code>是一个“纯虚函数”，子类必须实现。</p>
<p>Python使用如下方法达到纯虚函数的目的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">  <span class="string">"""Perform the action, after option parsing is complete.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure></p>
<p>那么main.py是如何执行命令指定命令的操作呢？main.py的主函数使用一个<code>_Repo</code>类的对象<code>repo</code>来表示Repo工具。该类主要实现了<code>_Run</code>函数，<code>_Repo</code>类对象就是用该函数来实现命令框架的。</p>
<p><code>_Run</code>函数首先根据命令行参数获取所要执行的命令名字，根据该名字从<code>all_commands</code>列表中取出对应该命令的对象。然后调用它的<code>Execute</code>函数执行子命令实现的功能。但是执行该命令所需的信息从哪里来呢（如manifest仓库在哪，仓库放置地址，用户信息等）？</p>
<p>阅读源码我们看到<code>_Run</code>函数为每个子命令对象创建了一个<code>XmlManifest</code>对象，该对象包含两个<code>MetaProject</code>对象，一个描述repo仓库，另一个描述manifest仓库。那么项目对象存储在哪里呢？我们可以想到的一种可能是项目对象也存储在XmlManifest对象中（也确实是这样）。</p>
<p>其实并不是所有的命令都需要知道项目仓库信息的，比如<code>init</code>命令。init命令仅仅下载一个manifest仓库，在manifest仓库下载下来之前，它也不可能有项目相关的对象。</p>
<p>一个需要使用项目仓库信息的命令是<code>sync</code>，它要下载所有的项目到本地，自然需要每一个项目的所有信息。XmlManifest对象有一个属性装饰器函数，它会在你获取XmlManifest对象时从清单文件里解析并创建出所有的项目对象并存储在一个列表中。</p>
<p>知道了所有所需要的信息之后<code>Cmd</code>对象就调用它自己实现的<code>Execute</code>函数来完成具体的工作。</p>
<p>下看我们来看以上这些分析的源代码。</p>
<h2 id="导入all-commands" class="article-heading"><a href="#导入all-commands" class="headerlink" title="导入all_commands"></a>导入all_commands<a class="article-anchor" href="#导入all-commands" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subcmds <span class="keyword">import</span> all_commands</span><br></pre></td></tr></table></figure>
<p>该导入操作会调用<code>subcmds</code>包的初始化脚本<code>__init__.py</code>，该脚本实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_commands = &#123;&#125;</span><br><span class="line"></span><br><span class="line">my_dir = os.path.dirname(__file__)</span><br><span class="line"><span class="keyword">for</span> py <span class="keyword">in</span> os.listdir(my_dir):</span><br><span class="line">  <span class="keyword">if</span> py == <span class="string">'__init__.py'</span>:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> py.endswith(<span class="string">'.py'</span>):</span><br><span class="line">    name = py[:<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line">    clsn = name.capitalize()</span><br><span class="line">    <span class="keyword">while</span> clsn.find(<span class="string">'_'</span>) &gt; <span class="number">0</span>:</span><br><span class="line">      h = clsn.index(<span class="string">'_'</span>)</span><br><span class="line">      clsn = clsn[<span class="number">0</span>:h] + clsn[h + <span class="number">1</span>:].capitalize()</span><br><span class="line"></span><br><span class="line">    mod = __import__(__name__,</span><br><span class="line">                     globals(),</span><br><span class="line">                     locals(),</span><br><span class="line">                     [<span class="string">'%s'</span> % name])</span><br><span class="line">    mod = getattr(mod, name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      cmd = getattr(mod, clsn)()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">      <span class="keyword">raise</span> SyntaxError(<span class="string">'%s/%s does not define class %s'</span> % (</span><br><span class="line">                         __name__, py, clsn))</span><br><span class="line"></span><br><span class="line">    name = name.replace(<span class="string">'_'</span>, <span class="string">'-'</span>)</span><br><span class="line">    cmd.NAME = name</span><br><span class="line">    all_commands[name] = cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'help'</span> <span class="keyword">in</span> all_commands:</span><br><span class="line">  all_commands[<span class="string">'help'</span>].commands = all_commands</span><br></pre></td></tr></table></figure>
<p>首先定义一个空的<code>all_commands</code>列表，获取<code>__init__.py</code>文件所在目录下的所有文件，除<code>__init__.py</code>文件外，针对其它每个文件名name，去除文件名后缀，使用<code>__import__</code>导入该模块，这样每个子命令模块的类对象就创建成功了。</p>
<p>继续使用该文件名name，使首字母大写，使以<code>&#39;_&#39;</code>分隔的单词首字母大写得到该文件名对应的类名，然后使用<code>getattr</code>函数取得子命令模块，再取得之前导入时创建的对应的类对象。把该类对象添加到以名文件名为索引的<code>all_commands</code>列表中，其中文件名中的<code>&#39;_&#39;</code>要替换为<code>&#39;-&#39;</code>。这样就得到了所有子命令的类对象列表。如果要添加子命令，只需继承自<code>Command</code>类，并实现其<code>Execute</code>纯虚函数即可。</p>
<h2 id="Main函数" class="article-heading"><a href="#Main函数" class="headerlink" title="_Main函数"></a>_Main函数<a class="article-anchor" href="#Main函数" aria-hidden="true"></a></h2><p>main.py文件入口调用<code>_Main</code>函数。该函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_Main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  opt, argv = opt.parse_args(argv)</span><br><span class="line"></span><br><span class="line">  repo = _Repo(opt.repodir)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      result = repo._Run(argv) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">      close_ssh()</span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>main函数首先实例化一个<code>_Repo</code>对象，初始化ssh，http，然后直接调用<code>_Repo</code>实例的<code>_Run</code>函数。</p>
<h2 id="Repo类" class="article-heading"><a href="#Repo类" class="headerlink" title="_Repo类"></a>_Repo类<a class="article-anchor" href="#Repo类" aria-hidden="true"></a></h2><p><code>_Repo</code>类主要实现了<code>_Run</code>函数，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Repo</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repodir)</span>:</span></span><br><span class="line">    self.repodir = repodir</span><br><span class="line">    self.commands = all_commands</span><br><span class="line">    <span class="comment"># add 'branch' as an alias for 'branches'</span></span><br><span class="line">    all_commands[<span class="string">'branch'</span>] = all_commands[<span class="string">'branches'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_Run</span><span class="params">(self, argv)</span>:</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      cmd = self.commands[name]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">      print(<span class="string">"repo: '%s' is not a repo command.  See 'repo help'."</span> % name,</span><br><span class="line">            file=sys.stderr)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    cmd.repodir = self.repodir</span><br><span class="line">    cmd.manifest = XmlManifest(cmd.repodir)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      result = cmd.Execute(copts, cargs)</span><br><span class="line">    <span class="keyword">except</span> (DownloadError, ManifestInvalidRevisionError,</span><br><span class="line">        NoManifestException) <span class="keyword">as</span> e:</span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><code>_Run</code>函数从<code>all_commands</code>列表中取得对应 <strong>子命令</strong> 对象（<code>cmd = self.commands[name]</code>）。设置该子命令对象的repo仓库地址，同时为该子命令对象创建一个manifest对象（<code>cmd.repodir = self.repodir</code>， <code>cmd.manifest = XmlManifest(cmd.repodir)</code>），repodir是我们前面创建的<code>.repo</code>目录（即整个AOSP的<code>.repo</code>库），XmlManifest对象又会创建两个<code>MetaProject</code>对象来管理repo仓库和manifest仓库，同时XmlManifest对象会通过自己的装饰器函数获取后续操作所需的大部分信息（如用户名，邮箱等等）。</p>
<p>最后调用 <strong>子命令</strong> 的<code>Execute</code>函数，执行该子命令的相应操作。所有的子命令都实现了<code>Execute</code>函数，使用该函数完成相应功能的操作。</p>
<h2 id="XmlManifest类" class="article-heading"><a href="#XmlManifest类" class="headerlink" title="XmlManifest类"></a>XmlManifest类<a class="article-anchor" href="#XmlManifest类" aria-hidden="true"></a></h2><p><code>XmlManifest</code>类在每个子命令类对象中描述该子命令操作所需要的基础信息，如.repo地址及所在目录，manifest文件路径，repo和manifest仓库对象以及所有要管理的项目对象。</p>
<p>我们摘取<code>XmlManifest</code>类的几个方法来看：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlManifest</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""manages the repo configuration file"""</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, repodir)</span>:</span></span><br><span class="line"></span><br><span class="line">    self.repoProject = MetaProject(self, <span class="string">'repo'</span>,</span><br><span class="line">      gitdir   = os.path.join(repodir, <span class="string">'repo/.git'</span>),</span><br><span class="line">      worktree = os.path.join(repodir, <span class="string">'repo'</span>))</span><br><span class="line"></span><br><span class="line">    self.manifestProject = MetaProject(self, <span class="string">'manifests'</span>,</span><br><span class="line">      gitdir   = os.path.join(repodir, <span class="string">'manifests.git'</span>),</span><br><span class="line">      worktree = os.path.join(repodir, <span class="string">'manifests'</span>))</span><br><span class="line"></span><br><span class="line">    self._Unload()</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="meta">  @property</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">projects</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._Load()</span><br><span class="line">    <span class="keyword">return</span> list(self._paths.values())</span><br></pre></td></tr></table></figure></p>
<p>先来看看初始化函数，<code>XmlManifest</code>类在初始化的时候会创建两个<code>MetaProject</code>类对象，一个对象是用来描述repo仓库，另一个用来描述manifest仓库。该<code>MetaProject</code>类派生自<code>Project</code>类，其实整个AOSP中的除了repo和manifest其它所有项目对象都是<code>Project</code>类型。</p>
<p>由于Repo和Manifest也是Git仓库，所以我们也需要创建一个Project对象来描述它们，不过，由于它们是比较特殊的Git仓库（用来描述AOSP子项目元信息的Git仓库），所以我们就使用另外一个类型为<code>MetaProject</code>的对象来描述它们。</p>
<p><code>def projects(self)</code>有一个属性装饰器，它会在你访问该属性或它所属对象时自动运行。它使用内部函数<code>_Load()</code>读取并解析manifest清单文件，并对每个项目创建<code>Project</code>类对象。就像后面会分析的一样，在创建每个项目对象时会分别指定它们的仓库地址与工作区地址，以达到工作区和仓库分离的目标。</p>
<h2 id="MetaProject类" class="article-heading"><a href="#MetaProject类" class="headerlink" title="MetaProject类"></a>MetaProject类<a class="article-anchor" href="#MetaProject类" aria-hidden="true"></a></h2><p><code>MetaProject</code>类继承自<code>Project</code>类，它的构造函数直接调用其基类的构造函数，实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaProject</span><span class="params">(Project)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, manifest, name, gitdir, worktree)</span>:</span></span><br><span class="line">    Project.__init__(self,</span><br><span class="line">                     manifest=manifest,</span><br><span class="line">                     name=name,</span><br><span class="line">                     gitdir=gitdir,</span><br><span class="line">                     objdir=gitdir,</span><br><span class="line">                     worktree=worktree,</span><br><span class="line">                     remote=RemoteSpec(<span class="string">'origin'</span>),</span><br><span class="line">                     relpath=<span class="string">'.repo/%s'</span> % name,</span><br><span class="line">                     revisionExpr=<span class="string">'refs/heads/master'</span>,</span><br><span class="line">                     revisionId=<span class="literal">None</span>,</span><br><span class="line">                     groups=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>在创建<code>repoProject</code>对象时传入的为repo仓库相关的参数（<code>[manifest=&#39;repo&#39;, gitdir=&#39;.repo/repo/.git&#39;,  worktree=&#39;.repo/repo&#39;]</code>），在创建<code>manifestProject</code>对象时传入manifest仓库相关的参数（<code>[manifest=&#39;manifests&#39;, gitdir=&#39;.repo/manifests.git&#39;, worktree=&#39;.repo/manifests&#39;]</code>）。</p>
<p>重点记住下面三个参数，后面会再说明：</p>
<ul>
<li>gitdir Git仓库存(.git)的放位置</li>
<li>objdir Git仓库对象文件存放位置</li>
<li>worktree 工作区位置</li>
</ul>
<p>这里传给基类的gitdir与objdir相同，这就使得repo和manifest仓库的仓库与对象存储在相同的位置。我们后面会看到在创建项目对象时，传入的gitdir与objdir是不相同的。</p>
<p>另外比较repo仓库与manifest仓库在创建时传入的参数，我们发现repo仓库的Git库和工作区是在同一个目录，而manifest仓库的Git库与工作区不是一个目录。为什么要不同呢？</p>
<p>先来看看下载完成后的带工作区的manifest仓库：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">~/WORKING_DIRECTORY/.repo/manifests/.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 8</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  26 4月  22 23:52 config -&gt; ../../manifests.git/config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  31 4月  22 23:52 description -&gt; ../../manifests.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  24 4月  22 23:52 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  25 4月  22 23:52 hooks -&gt; ../../manifests.git/hooks</span><br><span class="line">-rw-rw-r--. 1 zyl zyl 145 4月  22 23:52 index</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  24 4月  22 23:52 info -&gt; ../../manifests.git/info</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  24 4月  22 23:52 logs -&gt; ../../manifests.git/logs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  27 4月  22 23:52 objects -&gt; ../../manifests.git/objects</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  31 4月  22 23:52 packed-refs -&gt; ../../manifests.git/packed-refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  24 4月  22 23:52 refs -&gt; ../../manifests.git/refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  28 4月  22 23:52 rr-cache -&gt; ../../manifests.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl  23 4月  22 23:52 svn -&gt; ../../manifests.git/svn</span><br></pre></td></tr></table></figure></p>
<p>我们知道，repo仓库是前面通过引导文件下载的，最终是通过类似<code>git clone</code>的方式下载下来的，工作区和仓库是同一个目录。因此在创建管理repo仓库的对象时要传入相同的gitdir与worktree，而manifest仓库是由完整的Repo仓库的main.py模块下载的，它的下载与后面项目的下载类似，是仓库与工作区分开的。</p>
<p>为什么要创建一个<code>MetaProject</code>类，直接使用<code>Project</code>类不行吗？</p>
<p>我们来看看这两个类的区别，<code>MetaProject</code>类继承自<code>Project</code>类，但额外实现了两个函数，<code>PreSync</code>与<code>MetaBranchSwitch</code>。这两个函数配合主要是为了实现检出分支或更新仓库时使用已有的分支，而不是使用manifest文件里revision属性指定的分支。再者这两个库是为了管理项目的，并不是越新越好，而是要检出稳定的版本，这些都和项目类不同。</p>
<p>下面来看它的基类<code>Project</code>类的<code>__init__</code>函数。</p>
<h2 id="Project类的init函数" class="article-heading"><a href="#Project类的init函数" class="headerlink" title="Project类的init函数"></a>Project类的<strong>init</strong>函数<a class="article-anchor" href="#Project类的init函数" aria-hidden="true"></a></h2><p><code>Project</code>类对象用来描述一个AOSP子项目的各项信息，以及封装对git的基本操作，其<code>__init__</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Project</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="comment"># These objects can be shared between several working trees.</span></span><br><span class="line">  shareable_files = [<span class="string">'description'</span>, <span class="string">'info'</span>]</span><br><span class="line">  shareable_dirs = [<span class="string">'hooks'</span>, <span class="string">'objects'</span>, <span class="string">'rr-cache'</span>, <span class="string">'svn'</span>]</span><br><span class="line">  <span class="comment"># These objects can only be used by a single working tree.</span></span><br><span class="line">  working_tree_files = [<span class="string">'config'</span>, <span class="string">'packed-refs'</span>, <span class="string">'shallow'</span>]</span><br><span class="line">  working_tree_dirs = [<span class="string">'logs'</span>, <span class="string">'refs'</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">               manifest,</span></span></span><br><span class="line"><span class="function"><span class="params">               name,</span></span></span><br><span class="line"><span class="function"><span class="params">               remote,</span></span></span><br><span class="line"><span class="function"><span class="params">               gitdir,</span></span></span><br><span class="line"><span class="function"><span class="params">               objdir,</span></span></span><br><span class="line"><span class="function"><span class="params">               worktree,</span></span></span><br><span class="line"><span class="function"><span class="params">               relpath,</span></span></span><br><span class="line"><span class="function"><span class="params">               revisionExpr,</span></span></span><br><span class="line"><span class="function"><span class="params">               revisionId,</span></span></span><br><span class="line"><span class="function"><span class="params">               rebase=True,</span></span></span><br><span class="line"><span class="function"><span class="params">               groups=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               sync_c=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               sync_s=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               clone_depth=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               upstream=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               parent=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               is_derived=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               dest_branch=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               optimized_fetch=False,</span></span></span><br><span class="line"><span class="function"><span class="params">               old_revision=None)</span>:</span></span><br><span class="line">    self.manifest = manifest</span><br><span class="line">    self.name = name</span><br><span class="line">    self.remote = remote</span><br><span class="line">    self.gitdir = gitdir.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    self.objdir = objdir.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">if</span> worktree:</span><br><span class="line">      self.worktree = worktree.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.worktree = <span class="literal">None</span></span><br><span class="line">    self.relpath = relpath</span><br><span class="line">    self.revisionExpr = revisionExpr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>   revisionId <span class="keyword">is</span> <span class="literal">None</span> \</span><br><span class="line">     <span class="keyword">and</span> revisionExpr \</span><br><span class="line">     <span class="keyword">and</span> IsId(revisionExpr):</span><br><span class="line">      self.revisionId = revisionExpr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.revisionId = revisionId</span><br><span class="line"></span><br><span class="line">    self.rebase = rebase</span><br><span class="line">    self.groups = groups</span><br><span class="line">    self.sync_c = sync_c</span><br><span class="line">    self.sync_s = sync_s</span><br><span class="line">    self.clone_depth = clone_depth</span><br><span class="line">    self.upstream = upstream</span><br><span class="line">    self.parent = parent</span><br><span class="line">    self.is_derived = is_derived</span><br><span class="line">    self.optimized_fetch = optimized_fetch</span><br><span class="line">    self.subprojects = []</span><br><span class="line"></span><br><span class="line">    self.snapshots = &#123;&#125;</span><br><span class="line">    self.copyfiles = []</span><br><span class="line">    self.linkfiles = []</span><br><span class="line">    self.annotations = []</span><br><span class="line">    self.config = GitConfig.ForRepository(</span><br><span class="line">                    gitdir=self.gitdir,</span><br><span class="line">                    defaults=self.manifest.globalConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.worktree:</span><br><span class="line">      self.work_git = self._GitGetByExec(self, bare=<span class="literal">False</span>, gitdir=gitdir)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      self.work_git = <span class="literal">None</span></span><br><span class="line">    self.bare_git = self._GitGetByExec(self, bare=<span class="literal">True</span>, gitdir=gitdir)</span><br><span class="line">    self.bare_ref = GitRefs(gitdir)</span><br><span class="line">    self.bare_objdir = self._GitGetByExec(self, bare=<span class="literal">True</span>, gitdir=objdir)</span><br><span class="line">    self.dest_branch = dest_branch</span><br><span class="line">    self.old_revision = old_revision</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This will be filled in if a project is later identified to be the</span></span><br><span class="line">    <span class="comment"># project containing repo hooks.</span></span><br><span class="line">    self.enabled_repo_hooks = []</span><br></pre></td></tr></table></figure></p>
<p>该函数各参数的意义注释中有详细的说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>manifest</code></td>
<td>XmlManifest对象</td>
</tr>
<tr>
<td><code>name</code></td>
<td>项目名称</td>
</tr>
<tr>
<td><code>remote</code></td>
<td>项目对应的远程仓库信息</td>
</tr>
<tr>
<td><code>gitdir</code></td>
<td>Git仓库绝对路径</td>
</tr>
<tr>
<td><code>objdir</code></td>
<td>Git仓库对象存储的绝对路径</td>
</tr>
<tr>
<td><code>worktree</code></td>
<td>工作目录的绝对路径</td>
</tr>
<tr>
<td><code>relpath</code></td>
<td>工作目录相对于AOS根目录的相对路径</td>
</tr>
<tr>
<td><code>revisionExpr</code></td>
<td>manifest.xml中关于该项目的<code>revision</code>属性</td>
</tr>
<tr>
<td><code>revisionId</code></td>
<td>checkout out时的commit id</td>
</tr>
<tr>
<td><code>rebase</code></td>
<td>manifest.xml中关于该项目的<code>rebase</code>属性</td>
</tr>
<tr>
<td><code>groups</code></td>
<td>manifest.xml中关于该项目的<code>groups</code>属性</td>
</tr>
<tr>
<td><code>sync_c</code></td>
<td>manifest.xml中关于该项目的<code>sync_c</code>属性</td>
</tr>
<tr>
<td><code>sync_s</code></td>
<td>manifest.xml中关于该项目的<code>sync_s</code>属性</td>
</tr>
<tr>
<td><code>upstream</code></td>
<td>manifest.xml中关于该项目的<code>upstream</code>属性</td>
</tr>
<tr>
<td><code>parent</code></td>
<td>当前项目的父项目</td>
</tr>
<tr>
<td><code>is_derived</code></td>
<td>如果一个项目含有子模块（也是一个Git仓库），那么这些子模块也会用一个<code>Project</code>对象来描述，这些<code>Project</code>的<code>is_derived</code>属性会设置为true</td>
</tr>
<tr>
<td><code>dest_branch</code></td>
<td>默认的codereview分支，如果不指定则会取<code>revision</code>属性作为默认的codereview分支。</td>
</tr>
</tbody>
</table>
<p>前面已经提到，在项目属性中分别指定gitdir，objdir，worktree是因为在AOSP中，每一个子项目的存储对象、git仓库以及工作区目录是分开的。AOSP中项目的工作目录位于AOSP根目录下，Git仓库位于<code>.repo/repo/projects</code>目录下，而存储对象放在<code>.repo/repo/project-objects</code>目录下。</p>
<p>此外，每一个AOSP子项目的工作目录也有一个.git目录，不过这个.git目录下的大部分文件都是一个符号链接，指向<code>.repo/repo/projects</code>目录下对应的项目的Git目录（像manifest仓库那样）下的文件。这样，我们就可以在AOSP子项目的工作目录下执行Git命令，就像它的仓库就在本地一样，也可以在其Git仓库下执行Git命令。一般来说，要访问到工作目录的命令（例如<code>git status</code>）需要在工作目录下执行，而不需要访问工作目录（例如<code>git log</code>）可以在Git目录下执行。</p>
<p>下面来看这两个成员变量<code>work_git</code>和<code>bare_git</code>，它们指向的都是一个<code>_GitGetByExec</code>对象，该对象调用GitCommand类中的命令的执行Git操作。其中，前者在执行Git命令的时候，会将当前目录设置为项目的工作目录，而后者在执行的时候，不会设置当前目录，但是会将环境变量<code>GIT_DIR</code>的值设置为项目的Git目录，也就是<code>.repo/projects</code>目录下面的那些目录。这就是Repo能将仓库和工作区分开存储的真正原因。通过这种方式，子命令对象可以在工作区还没有创建.git时执行Git命令。</p>
<p>还是前面的问题，为什么要把这三个目录分开存放呢？通过Project类开头的注释可以看出这样设计可以在多个不同的工作区里共离一些东西。同时把对象存储在一起也可以更方便的管理与存储。</p>
<p>我们看一个项目的目录结构：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GIT_OBJECT_DIRECTORY目录下</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">.repo/project-objects/site.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 40</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 branches</span><br><span class="line">-rw-rw-r--.   1 zyl zyl   66 4月  23 00:01 config</span><br><span class="line">-rw-rw-r--.   1 zyl zyl   73 4月  23 00:01 description</span><br><span class="line">-rw-rw-r--.   1 zyl zyl   23 4月  23 00:01 HEAD</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 hooks</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 info</span><br><span class="line">drwxrwxr-x. 223 zyl zyl 4096 5月  23 19:27 objects</span><br><span class="line">drwxrwxr-x.   4 zyl zyl 4096 4月  23 00:01 refs</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 rr-cache</span><br><span class="line">drwxrwxr-x.   2 zyl zyl 4096 4月  23 00:01 svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIT_DIR目录下</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">.repo/projects/site.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 28</span><br><span class="line">drwxrwxr-x. 2 zyl zyl 4096 4月  23 00:01 branches</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  337 4月  30 22:24 config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   42 4月  23 00:01 description -&gt; ../../project-objects/site.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  453 5月  12 21:08 FETCH_HEAD</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   23 4月  23 00:01 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   36 4月  23 00:01 hooks -&gt; ../../project-objects/site.git/hooks</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   35 4月  23 00:01 info -&gt; ../../project-objects/site.git/info</span><br><span class="line">drwxrwxr-x. 3 zyl zyl 4096 4月  23 12:33 logs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   38 4月  23 00:01 objects -&gt; ../../project-objects/site.git/objects</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   39 4月  23 00:02 packed-refs</span><br><span class="line">drwxrwxr-x. 5 zyl zyl 4096 4月  23 00:16 refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   39 4月  23 00:01 rr-cache -&gt; ../../project-objects/site.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   34 4月  23 00:01 svn -&gt; ../../project-objects/site.git/svn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作区下的.git</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">site/.git</span><br><span class="line">$ ll</span><br><span class="line">总用量 28</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    59 5月  15 23:17 COMMIT_EDITMSG</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    36 4月  23 00:16 config -&gt; ../../.repo/projects/site.git/config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    48 4月  23 00:16 description -&gt; ../../.repo/project-objects/site.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    85 5月  23 21:06 FETCH_HEAD</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    23 4月  30 22:24 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    42 4月  23 00:16 hooks -&gt; ../../.repo/project-objects/site.git/hooks</span><br><span class="line">-rw-rw-r--. 1 zyl zyl 11733 5月  23 19:30 index</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    41 4月  23 00:16 info -&gt; ../../.repo/project-objects/site.git/info</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    34 4月  23 00:16 logs -&gt; ../../.repo/projects/site.git/logs</span><br><span class="line">-rw-rw-r--. 1 zyl zyl     0 5月  15 23:17 MERGE_RR</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    44 4月  23 00:16 objects -&gt; ../../.repo/project-objects/site.git/objects</span><br><span class="line">-rw-rw-r--. 1 zyl zyl    41 5月  23 19:27 ORIG_HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    41 4月  23 00:16 packed-refs -&gt; ../../.repo/projects/site.git/packed-refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    34 4月  23 00:16 refs -&gt; ../../.repo/projects/site.git/refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    45 4月  23 00:16 rr-cache -&gt; ../../.repo/project-objects/site.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl    40 4月  23 00:16 svn -&gt; ../../.repo/project-objects/site.git/svn</span><br></pre></td></tr></table></figure></p>
<h2 id="远程仓库的路径" class="article-heading"><a href="#远程仓库的路径" class="headerlink" title="远程仓库的路径"></a>远程仓库的路径<a class="article-anchor" href="#远程仓库的路径" aria-hidden="true"></a></h2><p>项目仓库的地址是如何得到的呢，Repo使用如下地址作为项目的fetch地址：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;remote_fetch&#125;</span>/<span class="variable">$&#123;project_name&#125;</span>.git</span><br></pre></td></tr></table></figure></p>
<p>其中remote_fetch就是manifest.xml文件中remote元素的fetch属性，该属性支持两种路径格式–绝对路径与相对路径。</p>
<ul>
<li>绝对路径： 如果指定绝对路径，则项目的地址就是上面格式的组合。</li>
<li>相对路径： 如果指定相对路径，则该路径为相对于命令行参数<code>-u</code>的路径，即相对于manifest仓库的路径。</li>
</ul>
<p>例如，如果在<code>repo init</code>时给的<code>-u</code>命令参数为<code>https://android.googlesource.com/platform/manifest</code>，并指定remote的fetch属性如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remote</span>  <span class="attr">name</span>=<span class="string">"aosp"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">fetch</span>=<span class="string">".."</span></span></span><br><span class="line"><span class="tag">         <span class="attr">review</span>=<span class="string">"https://android-review.googlesource.com/"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>则项目的路径为：<code>https://android.googlesource.com/platform/&lt;project_name&gt;.git</code>。</p>
<h1 id="REPO-INIT" class="article-heading"><a href="#REPO-INIT" class="headerlink" title="REPO INIT"></a>REPO INIT<a class="article-anchor" href="#REPO-INIT" aria-hidden="true"></a></h1><p>前面提到每个子命令都实现了<code>Execute</code>函数，用该函数来实现功能。前面引导加载的过程都相似，下面介绍<code>Init</code>类的<code>Execute</code>函数。<code>repo init</code>使用该部分同步manifest仓库。</p>
<h2 id="Init类的Execute函数" class="article-heading"><a href="#Init类的Execute函数" class="headerlink" title="Init类的Execute函数"></a>Init类的Execute函数<a class="article-anchor" href="#Init类的Execute函数" aria-hidden="true"></a></h2><p><code>init</code>命令的<code>Execute</code>实现如下，该函数主要使用两个内部函数<code>_SyncManifest</code>和<code>_LinkManifest</code>来完成功能：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Init</span><span class="params">(InteractiveCommand, MirrorSafeCommand)</span>:</span>  </span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">    git_require(MIN_GIT_VERSION, fail=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    self._SyncManifest(opt)</span><br><span class="line">    self._LinkManifest(opt.manifest_name)</span><br><span class="line"></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p><code>_SyncManifest</code>函数同步manifest仓库，<code>_LinkManifest</code>函数创建默认的manifest链接。下面具体分析。</p>
<h2 id="Init类的-SyncManifest函数" class="article-heading"><a href="#Init类的-SyncManifest函数" class="headerlink" title="Init类的_SyncManifest函数"></a>Init类的_SyncManifest函数<a class="article-anchor" href="#Init类的-SyncManifest函数" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_SyncManifest</span><span class="params">(self, opt)</span>:</span></span><br><span class="line">  m = self.manifest.manifestProject</span><br><span class="line">  is_new = <span class="keyword">not</span> m.Exists</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_new:</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    mirrored_manifest_git = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    m._InitGitDir(mirror_git=mirrored_manifest_git)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> opt.manifest_branch:</span><br><span class="line">      m.revisionExpr = opt.manifest_branch</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      m.revisionExpr = <span class="string">'refs/heads/master'</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> opt.manifest_branch:</span><br><span class="line">      m.revisionExpr = opt.manifest_branch</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      m.PreSync()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> opt.manifest_url:</span><br><span class="line">    r = m.GetRemote(m.remote.name)</span><br><span class="line">    r.url = opt.manifest_url</span><br><span class="line">    r.ResetFetch()</span><br><span class="line">    r.Save()</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> m.Sync_NetworkHalf(is_new=is_new):</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> opt.manifest_branch:</span><br><span class="line">    m.MetaBranchSwitch()</span><br><span class="line"></span><br><span class="line">  syncbuf = SyncBuffer(m.config)</span><br><span class="line">  m.Sync_LocalHalf(syncbuf)</span><br><span class="line">  syncbuf.Finish()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_new <span class="keyword">or</span> m.CurrentBranch <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m.StartBranch(<span class="string">'default'</span>):</span><br><span class="line">      print(<span class="string">'fatal: cannot create default in manifest'</span>, file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先设置前面创建的<code>MetaProject</code>类型的实例<code>manifestProject</code>对象为<code>m</code>，调用<code>m</code>的<code>_InitGitDir</code>函数创建仓库与对象目录，实际调用的是基类的<code>Project</code>类中的<code>_InitGitDir</code>函数。</li>
<li>设置<code>revisionExpr</code>变量指定需要获取的manifest仓库的分支。如果没有用<code>-b</code>指定则取默认的<code>master</code>分支。</li>
<li>使用<code>GetRemote</code>函数获取（创建）名字为<code>m.remote.name</code>的一个Remote远程仓库对象（第一次获取时该对象不存在，则创建该对象），配置该远程仓库对象的url，设置它的引用并保存配置。</li>
<li>使用<code>Sync_NetworkHalf</code>同步manifest仓库。</li>
<li>使用<code>Sync_LocalHalf</code>捡出指定的分支。</li>
</ul>
<h2 id="Project类图" class="article-heading"><a href="#Project类图" class="headerlink" title="Project类图"></a>Project类图<a class="article-anchor" href="#Project类图" aria-hidden="true"></a></h2><p>下图主列出了Project类的与库的下载与检出相关的两个函数，命令<code>init</code>和<code>sync</code>就是使用这两个函数来完成项目的下载与检出的。<br><img src="/img/class-project.png" alt="project"><br>其中repo的Git仓库对象repoProject和manifest的Git仓库对象manifestProject从MetaProject类产生，其它项目对象都是直接从Project类产生。</p>
<p>下面重点看<code>Sync_NetworkHalf</code>与<code>Sync_LocalHalf</code>函数。</p>
<h2 id="Project类的Sync-NetworkHalf函数" class="article-heading"><a href="#Project类的Sync-NetworkHalf函数" class="headerlink" title="Project类的Sync_NetworkHalf函数"></a>Project类的Sync_NetworkHalf函数<a class="article-anchor" href="#Project类的Sync-NetworkHalf函数" aria-hidden="true"></a></h2><p><code>Sync_NetworkHalf</code>函数首先调用<code>_InitGitDir</code>函数创建目录，然后调用<code>_ApplyCloneBundle</code>函数获取clone.bundle文件，而<code>_ApplyCloneBundle</code>函数通过调用<code>_FetchBundle</code>获取文件。这些步骤与前面获取repo仓库的bundle文件时差不多。</p>
<p><code>Sync_NetworkHalf</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sync_NetworkHalf</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">    quiet=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    is_new=None,</span></span></span><br><span class="line"><span class="function"><span class="params">    current_branch_only=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    force_sync=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    clone_bundle=True,</span></span></span><br><span class="line"><span class="function"><span class="params">    no_tags=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    archive=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    optimized_fetch=False,</span></span></span><br><span class="line"><span class="function"><span class="params">    prune=False)</span>:</span></span><br><span class="line">  <span class="string">"""Perform only the network IO portion of the sync process.</span></span><br><span class="line"><span class="string">     Local working directory/branch state is not affected.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_new:</span><br><span class="line">    self._InitGitDir(force_sync=force_sync)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self._UpdateHooks()</span><br><span class="line">  self._InitRemote()</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> clone_bundle \</span><br><span class="line">  <span class="keyword">and</span> alt_dir <span class="keyword">is</span> <span class="literal">None</span> \</span><br><span class="line">  <span class="keyword">and</span> self._ApplyCloneBundle(initial=is_new, quiet=quiet):</span><br><span class="line">    is_new = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  need_to_fetch = <span class="keyword">not</span> (optimized_fetch <span class="keyword">and</span> \</span><br><span class="line">    (ID_RE.match(self.revisionExpr) <span class="keyword">and</span> self._CheckForSha1()))</span><br><span class="line">  <span class="keyword">if</span> (need_to_fetch</span><br><span class="line">      <span class="keyword">and</span> <span class="keyword">not</span> self._RemoteFetch(initial=is_new, quiet=quiet, alt_dir=alt_dir,</span><br><span class="line">                                current_branch_only=current_branch_only,</span><br><span class="line">                                no_tags=no_tags, prune=prune)):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> self.worktree:</span><br><span class="line">    self._InitMRef()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self._InitMirrorHead()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      os.remove(os.path.join(self.gitdir, <span class="string">'FETCH_HEAD'</span>))</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<p><code>Sync_NetworkHalf</code>函数主要完成库对象的下载，工作区和分支状态不受影响。如果调用时<code>is_new</code>置为<code>true</code>表示一个新的仓库，会调用<code>_InitGitDir</code>来创建仓库的相关信息。否则调用<code>_UpdateHooks</code>更新引用。</p>
<h2 id="Project类的-InitGitDir函数" class="article-heading"><a href="#Project类的-InitGitDir函数" class="headerlink" title="Project类的_InitGitDir函数"></a>Project类的_InitGitDir函数<a class="article-anchor" href="#Project类的-InitGitDir函数" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_InitGitDir</span><span class="params">(self, mirror_git=None, force_sync=False)</span>:</span></span><br><span class="line">  init_git_dir = <span class="keyword">not</span> os.path.exists(self.gitdir)</span><br><span class="line">  init_obj_dir = <span class="keyword">not</span> os.path.exists(self.objdir)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize the bare repository, which contains all of the objects.</span></span><br><span class="line">    <span class="keyword">if</span> init_obj_dir:</span><br><span class="line">      os.makedirs(self.objdir)</span><br><span class="line">      self.bare_objdir.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If we have a separate directory to hold refs, initialize it as well.</span></span><br><span class="line">    <span class="keyword">if</span> self.objdir != self.gitdir:</span><br><span class="line">      <span class="keyword">if</span> init_git_dir:</span><br><span class="line">        os.makedirs(self.gitdir)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> init_obj_dir <span class="keyword">or</span> init_git_dir:</span><br><span class="line">        self._ReferenceGitDir(self.objdir, self.gitdir, share_refs=<span class="literal">False</span>,</span><br><span class="line">                              copy_all=<span class="literal">True</span>)</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> init_git_dir:</span><br><span class="line">      mp = self.manifest.manifestProject</span><br><span class="line">      </span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      self._UpdateHooks()</span><br><span class="line"></span><br><span class="line">      m = self.manifest.manifestProject.config</span><br><span class="line">      <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'user.name'</span>, <span class="string">'user.email'</span>]:</span><br><span class="line">        <span class="keyword">if</span> m.Has(key, include_defaults=<span class="literal">False</span>):</span><br><span class="line">          self.config.SetString(key, m.GetString(key))</span><br><span class="line">      <span class="keyword">if</span> self.manifest.IsMirror:</span><br><span class="line">        self.config.SetString(<span class="string">'core.bare'</span>, <span class="string">'true'</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        self.config.SetString(<span class="string">'core.bare'</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>_InitGitDir</code>函数首先判断当前项目的gitdir和objdir是否存在，如果objdir不存在，则创建objdir目录。manifest仓库的对象存储位置与仓库是同一目录，gitdir与objdir可以不同，如果objdir与gitdir不同，则创建gitdir目录，并创建引用，以便仓库可以找到对象的存储位置。然后调用<code>_UpdateHooks()</code>函数创建hooks目录并创建<code>commit-msg -&gt; ../../repo/hooks/commit-msg</code>，<code>pre-auto-gc -&gt; ../../repo/hooks/pre-auto-gc</code>两个连接连接向repo仓库下面hooks目录下的对应文件，这两个勾子文件是在commit msg中生成ChangeId的。然后设置用户名与用户邮件地址，设置该仓库是否是一个bare仓库。</p>
<p><code>Project</code>类定义哪些引用是所有工作树共享的，哪些引用是工作区私有的。对于所有工作区共享的引用实际上是<code>.repo/projects/&lt;PROJECT_NAME&gt;.git</code>目录到<code>.repo/project-objects/&lt;PROJECT_NAME&gt;.git</code>的链接。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These objects can be shared between several working trees.</span></span><br><span class="line">shareable_files = [<span class="string">'description'</span>, <span class="string">'info'</span>]</span><br><span class="line">shareable_dirs = [<span class="string">'hooks'</span>, <span class="string">'objects'</span>, <span class="string">'rr-cache'</span>, <span class="string">'svn'</span>]</span><br><span class="line"><span class="comment"># These objects can only be used by a single working tree.</span></span><br><span class="line">working_tree_files = [<span class="string">'config'</span>, <span class="string">'packed-refs'</span>, <span class="string">'shallow'</span>]</span><br><span class="line">working_tree_dirs = [<span class="string">'logs'</span>, <span class="string">'refs'</span>]</span><br></pre></td></tr></table></figure></p>
<p>下面看一个例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drwxrwxr-x. 2 zyl zyl 4096 4月  23 00:01 branches</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  337 4月  26 21:24 config</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   42 4月  23 00:01 description -&gt; ../../project-objects/site.git/description</span><br><span class="line">-rw-rw-r--. 1 zyl zyl  453 4月  29 14:40 FETCH_HEAD</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   23 4月  23 00:01 HEAD</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   36 4月  23 00:01 hooks -&gt; ../../project-objects/site.git/hooks</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   35 4月  23 00:01 info -&gt; ../../project-objects/site.git/info</span><br><span class="line">drwxrwxr-x. 3 zyl zyl 4096 4月  23 12:33 logs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   38 4月  23 00:01 objects -&gt; ../../project-objects/site.git/objects</span><br><span class="line">-rw-rw-r--. 1 zyl zyl   39 4月  23 00:02 packed-refs</span><br><span class="line">drwxrwxr-x. 5 zyl zyl 4096 4月  23 00:16 refs</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   39 4月  23 00:01 rr-cache -&gt; ../../project-objects/site.git/rr-cache</span><br><span class="line">lrwxrwxrwx. 1 zyl zyl   34 4月  23 00:01 svn -&gt; ../../project-objects/site.git/svn</span><br></pre></td></tr></table></figure></p>
<h2 id="ApplyCloneBundle函数实现" class="article-heading"><a href="#ApplyCloneBundle函数实现" class="headerlink" title="_ApplyCloneBundle函数实现"></a>_ApplyCloneBundle函数实现<a class="article-anchor" href="#ApplyCloneBundle函数实现" aria-hidden="true"></a></h2><p><code>_ApplyCloneBundle</code>函数实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ApplyCloneBundle</span><span class="params">(self, initial=False, quiet=False)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> initial <span class="keyword">and</span> (self.manifest.manifestProject.config.GetString(<span class="string">'repo.depth'</span>) <span class="keyword">or</span> self.clone_depth):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  remote = self.GetRemote(self.remote.name)</span><br><span class="line">  bundle_url = remote.url + <span class="string">'/clone.bundle'</span></span><br><span class="line">  bundle_url = GitConfig.ForUser().UrlInsteadOf(bundle_url)</span><br><span class="line">  <span class="keyword">if</span> GetSchemeFromUrl(bundle_url) <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">      <span class="string">'http'</span>, <span class="string">'https'</span>, <span class="string">'persistent-http'</span>, <span class="string">'persistent-https'</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  bundle_dst = os.path.join(self.gitdir, <span class="string">'clone.bundle'</span>)</span><br><span class="line">  bundle_tmp = os.path.join(self.gitdir, <span class="string">'clone.bundle.tmp'</span>)</span><br><span class="line"></span><br><span class="line">  exist_dst = os.path.exists(bundle_dst)</span><br><span class="line">  exist_tmp = os.path.exists(bundle_tmp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> initial <span class="keyword">and</span> <span class="keyword">not</span> exist_dst <span class="keyword">and</span> <span class="keyword">not</span> exist_tmp:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> exist_dst:</span><br><span class="line">    exist_dst = self._FetchBundle(bundle_url, bundle_tmp, bundle_dst, quiet)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> exist_dst:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  cmd = [<span class="string">'fetch'</span>]</span><br><span class="line">  <span class="keyword">if</span> quiet:</span><br><span class="line">    cmd.append(<span class="string">'--quiet'</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> self.worktree:</span><br><span class="line">    cmd.append(<span class="string">'--update-head-ok'</span>)</span><br><span class="line">  cmd.append(bundle_dst)</span><br><span class="line">  <span class="keyword">for</span> f <span class="keyword">in</span> remote.fetch:</span><br><span class="line">    cmd.append(str(f))</span><br><span class="line">  cmd.append(<span class="string">'refs/tags/*:refs/tags/*'</span>)</span><br><span class="line"></span><br><span class="line">  ok = GitCommand(self, cmd, bare=<span class="literal">True</span>).Wait() == <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> os.path.exists(bundle_dst):</span><br><span class="line">    os.remove(bundle_dst)</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(bundle_tmp):</span><br><span class="line">    os.remove(bundle_tmp)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br></pre></td></tr></table></figure></p>
<p><code>_FetchBundle</code>函数检查有无代理，然后下载bundle文件，从<code>_FetchBundle</code>函数可以看出，只需要在环境变量中设置<code>http_proxy</code>变量指定代理地址就可以了。</p>
<h2 id="Sync-LocalHalf函数实现" class="article-heading"><a href="#Sync-LocalHalf函数实现" class="headerlink" title="Sync_LocalHalf函数实现"></a>Sync_LocalHalf函数实现<a class="article-anchor" href="#Sync-LocalHalf函数实现" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sync_LocalHalf</span><span class="params">(self, syncbuf, force_sync=False)</span>:</span></span><br><span class="line">  <span class="string">"""Perform only the local IO portion of the sync process.</span></span><br><span class="line"><span class="string">     Network access is not required.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  self._InitWorkTree(force_sync=force_sync)</span><br><span class="line">  all_refs = self.bare_ref.all</span><br><span class="line">  self.CleanPublishedCache(all_refs)</span><br><span class="line">  revid = self.GetRevisionId(all_refs)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_doff</span><span class="params">()</span>:</span></span><br><span class="line">    self._FastForward(revid)</span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line"></span><br><span class="line">  head = self.work_git.GetHead()</span><br><span class="line">  <span class="keyword">if</span> head.startswith(R_HEADS):</span><br><span class="line">    branch = head[len(R_HEADS):]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      head = all_refs[head]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">      head = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    branch = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> branch <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> syncbuf.detach_head:</span><br><span class="line">    <span class="comment"># Currently on a detached HEAD.  The user is assumed to</span></span><br><span class="line">    <span class="comment"># not have any local modifications worth worrying about.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> self.IsRebaseInProgress():</span><br><span class="line">      syncbuf.fail(self, _PriorSyncFailedError())</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == revid:</span><br><span class="line">      <span class="comment"># No changes; don't do anything further.</span></span><br><span class="line">      <span class="comment"># Except if the head needs to be detached</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> syncbuf.detach_head:</span><br><span class="line">        <span class="comment"># The copy/linkfile config may have changed.</span></span><br><span class="line">        self._CopyAndLinkFiles()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      lost = self._revlist(not_rev(revid), HEAD)</span><br><span class="line">      <span class="keyword">if</span> lost:</span><br><span class="line">        syncbuf.info(self, <span class="string">"discarding %d commits"</span>, len(lost))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self._Checkout(revid, quiet=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> GitError <span class="keyword">as</span> e:</span><br><span class="line">      syncbuf.fail(self, e)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> head == revid:</span><br><span class="line">    <span class="comment"># No changes; don't do anything further.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># The copy/linkfile config may have changed.</span></span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  branch = self.GetBranch(branch)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> branch.LocalMerge:</span><br><span class="line">    <span class="comment"># The current branch has no tracking configuration.</span></span><br><span class="line">    <span class="comment"># Jump off it to a detached HEAD.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    syncbuf.info(self,</span><br><span class="line">                 <span class="string">"leaving %s; does not track upstream"</span>,</span><br><span class="line">                 branch.name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self._Checkout(revid, quiet=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">except</span> GitError <span class="keyword">as</span> e:</span><br><span class="line">      syncbuf.fail(self, e)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  upstream_gain = self._revlist(not_rev(HEAD), revid)</span><br><span class="line">  pub = self.WasPublished(branch.name, all_refs)</span><br><span class="line">  <span class="keyword">if</span> pub:</span><br><span class="line">    not_merged = self._revlist(not_rev(revid), pub)</span><br><span class="line">    <span class="keyword">if</span> not_merged:</span><br><span class="line">      <span class="keyword">if</span> upstream_gain:</span><br><span class="line">        <span class="comment"># The user has published this branch and some of those</span></span><br><span class="line">        <span class="comment"># commits are not yet merged upstream.  We do not want</span></span><br><span class="line">        <span class="comment"># to rewrite the published commits so we punt.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        syncbuf.fail(self,</span><br><span class="line">                     <span class="string">"branch %s is published (but not merged) and is now "</span></span><br><span class="line">                     <span class="string">"%d commits behind"</span> % (branch.name, len(upstream_gain)))</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">elif</span> pub == head:</span><br><span class="line">      <span class="comment"># All published commits are merged, and thus we are a</span></span><br><span class="line">      <span class="comment"># strict subset.  We can fast-forward safely.</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      syncbuf.later1(self, _doff)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Examine the local commits not in the remote.  Find the</span></span><br><span class="line">  <span class="comment"># last one attributed to this user, if any.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  local_changes = self._revlist(not_rev(revid), HEAD, format=<span class="string">'%H %ce'</span>)</span><br><span class="line">  last_mine = <span class="literal">None</span></span><br><span class="line">  cnt_mine = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> commit <span class="keyword">in</span> local_changes:</span><br><span class="line">    commit_id, committer_email = commit.decode(<span class="string">'utf-8'</span>).split(<span class="string">' '</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> committer_email == self.UserEmail:</span><br><span class="line">      last_mine = commit_id</span><br><span class="line">      cnt_mine += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> upstream_gain <span class="keyword">and</span> cnt_mine == len(local_changes):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> self.IsDirty(consider_untracked=<span class="literal">False</span>):</span><br><span class="line">    syncbuf.fail(self, _DirtyError())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If the upstream switched on us, warn the user.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="keyword">if</span> branch.merge != self.revisionExpr:</span><br><span class="line">    <span class="keyword">if</span> branch.merge <span class="keyword">and</span> self.revisionExpr:</span><br><span class="line">      syncbuf.info(self,</span><br><span class="line">                   <span class="string">'manifest switched %s...%s'</span>,</span><br><span class="line">                   branch.merge,</span><br><span class="line">                   self.revisionExpr)</span><br><span class="line">    <span class="keyword">elif</span> branch.merge:</span><br><span class="line">      syncbuf.info(self,</span><br><span class="line">                   <span class="string">'manifest no longer tracks %s'</span>,</span><br><span class="line">                   branch.merge)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> cnt_mine &lt; len(local_changes):</span><br><span class="line">    <span class="comment"># Upstream rebased.  Not everything in HEAD</span></span><br><span class="line">    <span class="comment"># was created by this user.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    syncbuf.info(self,</span><br><span class="line">                 <span class="string">"discarding %d commits removed from upstream"</span>,</span><br><span class="line">                 len(local_changes) - cnt_mine)</span><br><span class="line"></span><br><span class="line">  branch.remote = self.GetRemote(self.remote.name)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> ID_RE.match(self.revisionExpr):</span><br><span class="line">    <span class="comment"># in case of manifest sync the revisionExpr might be a SHA1</span></span><br><span class="line">    branch.merge = self.revisionExpr</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> branch.merge.startswith(<span class="string">'refs/'</span>):</span><br><span class="line">      branch.merge = R_HEADS + branch.merge</span><br><span class="line">  branch.Save()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> cnt_mine &gt; <span class="number">0</span> <span class="keyword">and</span> self.rebase:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dorebase</span><span class="params">()</span>:</span></span><br><span class="line">      self._Rebase(upstream=<span class="string">'%s^1'</span> % last_mine, onto=revid)</span><br><span class="line">      self._CopyAndLinkFiles()</span><br><span class="line">    syncbuf.later2(self, _dorebase)</span><br><span class="line">  <span class="keyword">elif</span> local_changes:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self._ResetHard(revid)</span><br><span class="line">      self._CopyAndLinkFiles()</span><br><span class="line">    <span class="keyword">except</span> GitError <span class="keyword">as</span> e:</span><br><span class="line">      syncbuf.fail(self, e)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    syncbuf.later1(self, _doff)</span><br></pre></td></tr></table></figure>
<p>该函数不需要网络，仅是将前面获取到的更新合入本地工作区。该函数会比较当已检出的引用与仓库的引用的，确认本地仓库比远程仓库超前还是落后，如果远程仓库的引用本地没有，则使用<code>rebase</code>方式更新本地引用并合并到工作区。</p>
<h2 id="Init类的-LinkManifest函数" class="article-heading"><a href="#Init类的-LinkManifest函数" class="headerlink" title="Init类的_LinkManifest函数"></a>Init类的_LinkManifest函数<a class="article-anchor" href="#Init类的-LinkManifest函数" aria-hidden="true"></a></h2><p>_LinkManifest函数比较简单，仅仅使用<code>-m</code>参数传入的或默认的文件名创建一个链接。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_LinkManifest</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">      print(<span class="string">'fatal: manifest name (-m) is required.'</span>, file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      self.manifest.Link(name)</span><br><span class="line">    <span class="keyword">except</span> ManifestParseError <span class="keyword">as</span> e:</span><br><span class="line">      print(<span class="string">"fatal: manifest '%s' not available"</span> % name, file=sys.stderr)</span><br><span class="line">      print(<span class="string">'fatal: %s'</span> % str(e), file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>至此<code>repo init</code>就结束了它的工作。然后即可使用<code>repo sync</code>同步所有项目。</p>
<h1 id="REPO-SYNC" class="article-heading"><a href="#REPO-SYNC" class="headerlink" title="REPO SYNC"></a>REPO SYNC<a class="article-anchor" href="#REPO-SYNC" aria-hidden="true"></a></h1><p>下面来看<code>sync</code>命令的<code>Execute</code>函数。该函数第一次运行时要根据 manifest 文件下载所有项目，之后再运行则同步所有项目到最新，所以该子命令比较复杂，但这里使用的大部分函数前面都用到过。</p>
<h2 id="sync命令的Execute函数实现" class="article-heading"><a href="#sync命令的Execute函数实现" class="headerlink" title="sync命令的Execute函数实现"></a>sync命令的Execute函数实现<a class="article-anchor" href="#sync命令的Execute函数实现" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  rp = self.manifest.repoProject</span><br><span class="line">  rp.PreSync()</span><br><span class="line"></span><br><span class="line">  mp = self.manifest.manifestProject</span><br><span class="line">  mp.PreSync()</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> opt.local_only:</span><br><span class="line">    mp.Sync_NetworkHalf(quiet=opt.quiet,</span><br><span class="line">                        current_branch_only=opt.current_branch_only,</span><br><span class="line">                        no_tags=opt.no_tags,</span><br><span class="line">                        optimized_fetch=opt.optimized_fetch)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  all_projects = self.GetProjects(args,</span><br><span class="line">                                  missing_ok=<span class="literal">True</span>,</span><br><span class="line">                                  submodules_ok=opt.fetch_submodules)</span><br><span class="line"></span><br><span class="line">  self._fetch_times = _FetchTimes(self.manifest)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> opt.local_only:</span><br><span class="line">    to_fetch = []</span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="keyword">if</span> _ONE_DAY_S &lt;= (now - rp.LastFetch):</span><br><span class="line">      to_fetch.append(rp)</span><br><span class="line">    to_fetch.extend(all_projects)</span><br><span class="line">    to_fetch.sort(key=self._fetch_times.Get, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    fetched = self._Fetch(to_fetch, opt)</span><br><span class="line">    _PostRepoFetch(rp, opt.no_repo_verify)</span><br><span class="line">    <span class="keyword">if</span> opt.network_only:</span><br><span class="line">      <span class="comment"># bail out now; the rest touches the working tree</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Iteratively fetch missing and/or nested unregistered submodules</span></span><br><span class="line">    previously_missing_set = set()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      self._ReloadManifest(manifest_name)</span><br><span class="line">      all_projects = self.GetProjects(args,</span><br><span class="line">                                      missing_ok=<span class="literal">True</span>,</span><br><span class="line">                                      submodules_ok=opt.fetch_submodules)</span><br><span class="line">      missing = []</span><br><span class="line">      <span class="keyword">for</span> project <span class="keyword">in</span> all_projects:</span><br><span class="line">        <span class="keyword">if</span> project.gitdir <span class="keyword">not</span> <span class="keyword">in</span> fetched:</span><br><span class="line">          missing.append(project)</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> missing:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="comment"># Stop us from non-stopped fetching actually-missing repos: If set of</span></span><br><span class="line">      <span class="comment"># missing repos has not been changed from last fetch, we break.</span></span><br><span class="line">      missing_set = set(p.name <span class="keyword">for</span> p <span class="keyword">in</span> missing)</span><br><span class="line">      <span class="keyword">if</span> previously_missing_set == missing_set:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      previously_missing_set = missing_set</span><br><span class="line">      fetched.update(self._Fetch(missing, opt))</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  syncbuf = SyncBuffer(mp.config,</span><br><span class="line">                        detach_head = opt.detach_head)</span><br><span class="line">  pm = Progress(<span class="string">'Syncing work tree'</span>, len(all_projects))</span><br><span class="line">  <span class="keyword">for</span> project <span class="keyword">in</span> all_projects:</span><br><span class="line">    pm.update()</span><br><span class="line">    <span class="keyword">if</span> project.worktree:</span><br><span class="line">      project.Sync_LocalHalf(syncbuf, force_sync=opt.force_sync)</span><br><span class="line">  pm.end()</span><br><span class="line">  print(file=sys.stderr)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> syncbuf.Finish():</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># If there's a notice that's supposed to print at the end of the sync, print</span></span><br><span class="line">  <span class="comment"># it now...</span></span><br><span class="line">  <span class="keyword">if</span> self.manifest.notice:</span><br><span class="line">    print(self.manifest.notice)</span><br></pre></td></tr></table></figure>
<p>首先取得<code>repoProject</code>和<code>manifestProject</code>两个对象，对这两个对象调用<code>PreSync</code>函数获取当前分支跟踪的远程分支负给<code>revisionExpr</code>，后续的<code>Sync_NetworkHalf</code>会使用该值来决定是否需要从远程仓库更新对象。前面已经讲过<code>Sync_NetworkHalf</code>函数，它使用<code>_InitGitDir</code>函数（如果仓库不存大）创建仓库目录并下载对象数据，或使用<code>_UpdateHooks</code>函数(仓库存在)创建<code>commit-msg -&gt; ../../repo/hooks/commit-msg</code>，<code>pre-auto-gc -&gt; ../../repo/hooks/pre-auto-gc</code>两个软链接链接向repo仓库下面hooks目录下的对应文件。该勾子脚本对Repo与Gerrit的协作起着至关重要的作用。这里之所以针对<code>manifestProject</code>对象再调用一次主要是为了防止清单库有更新，如果有更新，在同步项目时确保同步的是最新的清单文件指定的项目。</p>
<p>然后从清单文件获取所有的项目列表，使用<code>_Fetch</code>函数获取项目全部（第一次）或更新的对象文件到对应的远程分支上，并对照清单文件做一个检查，如果有未下载的再下载一次。之后为每个项目创建一个线程，在线程内部使用<code>Sync_LocalHalf</code>函数<code>rebase</code>到工作区。</p>
<p><code>Sync_LocalHalf</code>函数主要通过<code>git rebase</code>命令来完成工作，主要有以下几种情况：</p>
<ul>
<li>如果工作区当前处理分离头指针状态：直接检出最新的引用ID。</li>
<li>如果工作区当前处理本地分支上：直接检出最新的引用ID，使其处理分离头指针状态。</li>
<li>如果工作区当前处理本地远程跟踪分支上：如果工作区有未推送的提交则执行<code>git rebase</code>合并。</li>
</ul>
<h1 id="REPO-START" class="article-heading"><a href="#REPO-START" class="headerlink" title="REPO START"></a>REPO START<a class="article-anchor" href="#REPO-START" aria-hidden="true"></a></h1><p>下面来看<code>start</code>命令的<code>Execute</code>函数。</p>
<h2 id="start命令的Execute函数实现" class="article-heading"><a href="#start命令的Execute函数实现" class="headerlink" title="start命令的Execute函数实现"></a>start命令的Execute函数实现<a class="article-anchor" href="#start命令的Execute函数实现" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Start</span><span class="params">(Command)</span>:</span></span><br><span class="line">  common = <span class="literal">True</span></span><br><span class="line">  helpSummary = <span class="string">"Start a new branch for development"</span></span><br><span class="line">  helpUsage = <span class="string">"""</span></span><br><span class="line"><span class="string">%prog &lt;newbranchname&gt; [--all | &lt;project&gt;...]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">  helpDescription = <span class="string">"""</span></span><br><span class="line"><span class="string">'%prog' begins a new branch of development, starting from the</span></span><br><span class="line"><span class="string">revision specified in the manifest.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_Options</span><span class="params">(self, p)</span>:</span></span><br><span class="line">    p.add_option(<span class="string">'--all'</span>,</span><br><span class="line">                 dest=<span class="string">'all'</span>, action=<span class="string">'store_true'</span>,</span><br><span class="line">                 help=<span class="string">'begin branch in all projects'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Execute</span><span class="params">(self, opt, args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args:</span><br><span class="line">      self.Usage()</span><br><span class="line"></span><br><span class="line">    nb = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> git.check_ref_format(<span class="string">'heads/%s'</span> % nb):</span><br><span class="line">      print(<span class="string">"error: '%s' is not a valid name"</span> % nb, file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    err = []</span><br><span class="line">    projects = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> opt.all:</span><br><span class="line">      projects = args[<span class="number">1</span>:]</span><br><span class="line">      <span class="keyword">if</span> len(projects) &lt; <span class="number">1</span>:</span><br><span class="line">        projects = [<span class="string">'.'</span>,]  <span class="comment"># start it in the local project by default</span></span><br><span class="line"></span><br><span class="line">    all_projects = self.GetProjects(projects,</span><br><span class="line">                                    missing_ok=bool(self.gitc_manifest))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This must happen after we find all_projects, since GetProjects may need</span></span><br><span class="line">    <span class="comment"># the local directory, which will disappear once we save the GITC manifest.</span></span><br><span class="line">    <span class="keyword">if</span> self.gitc_manifest:</span><br><span class="line">      gitc_projects = self.GetProjects(projects, manifest=self.gitc_manifest,</span><br><span class="line">                                       missing_ok=<span class="literal">True</span>)</span><br><span class="line">      <span class="keyword">for</span> project <span class="keyword">in</span> gitc_projects:</span><br><span class="line">        <span class="keyword">if</span> project.old_revision:</span><br><span class="line">          project.already_synced = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          project.already_synced = <span class="literal">False</span></span><br><span class="line">          project.old_revision = project.revisionExpr</span><br><span class="line">        project.revisionExpr = <span class="literal">None</span></span><br><span class="line">      <span class="comment"># Save the GITC manifest.</span></span><br><span class="line">      gitc_utils.save_manifest(self.gitc_manifest)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Make sure we have a valid CWD</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.getcwd()):</span><br><span class="line">        os.chdir(self.manifest.topdir)</span><br><span class="line"></span><br><span class="line">    pm = Progress(<span class="string">'Starting %s'</span> % nb, len(all_projects))</span><br><span class="line">    <span class="keyword">for</span> project <span class="keyword">in</span> all_projects:</span><br><span class="line">      pm.update()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> self.gitc_manifest:</span><br><span class="line">        gitc_project = self.gitc_manifest.paths[project.relpath]</span><br><span class="line">        <span class="comment"># Sync projects that have not been opened.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> gitc_project.already_synced:</span><br><span class="line">          proj_localdir = os.path.join(self.gitc_manifest.gitc_client_dir,</span><br><span class="line">                                       project.relpath)</span><br><span class="line">          project.worktree = proj_localdir</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(proj_localdir):</span><br><span class="line">            os.makedirs(proj_localdir)</span><br><span class="line">          project.Sync_NetworkHalf()</span><br><span class="line">          sync_buf = SyncBuffer(self.manifest.manifestProject.config)</span><br><span class="line">          project.Sync_LocalHalf(sync_buf)</span><br><span class="line">          project.revisionId = gitc_project.old_revision</span><br><span class="line"></span><br><span class="line">      <span class="comment"># If the current revision is a specific SHA1 then we can't push back</span></span><br><span class="line">      <span class="comment"># to it; so substitute with dest_branch if defined, or with manifest</span></span><br><span class="line">      <span class="comment"># default revision instead.</span></span><br><span class="line">      branch_merge = <span class="string">''</span></span><br><span class="line">      <span class="keyword">if</span> IsId(project.revisionExpr):</span><br><span class="line">        <span class="keyword">if</span> project.dest_branch:</span><br><span class="line">          branch_merge = project.dest_branch</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          branch_merge = self.manifest.default.revisionExpr</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> project.StartBranch(nb, branch_merge=branch_merge):</span><br><span class="line">        err.append(project)</span><br><span class="line">    pm.end()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err:</span><br><span class="line">      <span class="keyword">for</span> p <span class="keyword">in</span> err:</span><br><span class="line">        print(<span class="string">"error: %s/: cannot start %s"</span> % (p.relpath, nb),</span><br><span class="line">              file=sys.stderr)</span><br><span class="line">      sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从源代码中也可以看到<code>start</code>命令的使用方法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo start &lt;newbranchname&gt; [--all | &lt;project&gt;...]</span><br></pre></td></tr></table></figure></p>
<p>如果没有提供<code>--all</code>参数，则取后面指定的<code>&lt;project&gt;</code>列表作为操作对象，如果<code>&lt;project&gt;</code>为空，则取当前目录所在的项目作为操作项目。</p>
<p>为每一个项目创建一个线程来处理。该线程首先检查当前分支所处的状态，如果处于“分离头指针”（即处于具体的 SHA1 上）状态，则判断是否定义默认的codereview分支（<code>dest_branch</code>默认codereview分支由清单文件的<code>dest-branch</code>属性指定），如果有则使用清单文件指定的默认的codereview分支作为<code>branch_merge</code>的值，如果没有则使用manifest.xml中指定的关于该项目的revision属性作为<code>branch_merge</code>的值。接下来使用新的分支名<code>&lt;newbranchname&gt;</code>和<code>branch_merge</code>作参数调用<code>project</code>类的<code>StartBranch</code>创建新分支。</p>
<p>如果项目刚同步下来第一次调用<code>repo start</code>此时项目处理分离头指针状态，且默认的manifest文件没有指定<code>dest-branch</code>属性，所以<code>dest_branch</code>取manifest.xml中关于该项目的<code>revision</code>属性。如果项目已处理某个分支之上，则<code>dest_branch</code>为空。后面会看到如果入参<code>dest_branch</code>为空，会取项目当前所处的分支。</p>
<h2 id="project类的StartBranch函数" class="article-heading"><a href="#project类的StartBranch函数" class="headerlink" title="project类的StartBranch函数"></a>project类的StartBranch函数<a class="article-anchor" href="#project类的StartBranch函数" aria-hidden="true"></a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StartBranch</span><span class="params">(self, name, branch_merge=<span class="string">''</span>)</span>:</span></span><br><span class="line">  <span class="string">"""Create a new branch off the manifest's revision.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> branch_merge:</span><br><span class="line">    branch_merge = self.revisionExpr</span><br><span class="line">  head = self.work_git.GetHead()</span><br><span class="line">  <span class="keyword">if</span> head == (R_HEADS + name):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  all_refs = self.bare_ref.all</span><br><span class="line">  <span class="keyword">if</span> R_HEADS + name <span class="keyword">in</span> all_refs:</span><br><span class="line">    <span class="keyword">return</span> GitCommand(self,</span><br><span class="line">                      [<span class="string">'checkout'</span>, name, <span class="string">'--'</span>],</span><br><span class="line">                      capture_stdout=<span class="literal">True</span>,</span><br><span class="line">                      capture_stderr=<span class="literal">True</span>).Wait() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  branch = self.GetBranch(name)</span><br><span class="line">  branch.remote = self.GetRemote(self.remote.name)</span><br><span class="line">  branch.merge = branch_merge</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> branch.merge.startswith(<span class="string">'refs/'</span>) <span class="keyword">and</span> <span class="keyword">not</span> ID_RE.match(branch_merge):</span><br><span class="line">    branch.merge = R_HEADS + branch_merge</span><br><span class="line">  revid = self.GetRevisionId(all_refs)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> head.startswith(R_HEADS):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      head = all_refs[head]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">      head = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">if</span> revid <span class="keyword">and</span> head <span class="keyword">and</span> revid == head:</span><br><span class="line">    ref = os.path.join(self.gitdir, R_HEADS + name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      os.makedirs(os.path.dirname(ref))</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    _lwrite(ref, <span class="string">'%s\n'</span> % revid)</span><br><span class="line">    _lwrite(os.path.join(self.worktree, <span class="string">'.git'</span>, HEAD),</span><br><span class="line">            <span class="string">'ref: %s%s\n'</span> % (R_HEADS, name))</span><br><span class="line">    branch.Save()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> GitCommand(self,</span><br><span class="line">                [<span class="string">'checkout'</span>, <span class="string">'-b'</span>, branch.name, revid],</span><br><span class="line">                capture_stdout=<span class="literal">True</span>,</span><br><span class="line">                capture_stderr=<span class="literal">True</span>).Wait() == <span class="number">0</span>:</span><br><span class="line">    branch.Save()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>在project.py文件的<code>project</code>类中<code>StartBranch</code>以及之后的<code>CheckoutBranch</code>、<code>AbandonBranch</code>、<code>PruneHeads</code>几个函数主要是用作分支管理的。后续的<code>repo checkout</code>、<code>repo abandon</code>、<code>repo prune</code>就是使用它们来完成工作的。在这里只分支<code>StartBranch</code>函数，其它的函数后续遇到的时候再分析。</p>
<p>检查当前分支是不是要创建的分支，如果是就什么也不做，如果不是再检查要创建的分支是否已存在，如果存在就检出该分支。</p>
<h1 id="REPO-UPLOAD" class="article-heading"><a href="#REPO-UPLOAD" class="headerlink" title="REPO UPLOAD"></a>REPO UPLOAD<a class="article-anchor" href="#REPO-UPLOAD" aria-hidden="true"></a></h1><p>在执行upload时，如果指定了项目则从指定项目中查找，如果没有指定则遍历所有项目。</p>
<p>Repo工具为每一个项目添加一个<code>refs/published/&lt;branch_name&gt;</code>引用文件来记录该分支的最新upload引用。</p>
<p>对于一个项目的所有topic分支，获取未upload的变更的过程如下：</p>
<ol>
<li>首行比较它的<code>refs/heads/&lt;branch_name&gt;</code>与对应的<code>refs/published/&lt;branch_name&gt;</code>，如果两个引用的ref_id相同，就认为所有提交都已提交Review。</li>
<li>否则就获取该分支的未推送变更，如果没有未推送变更，则认为所有提交都已提交Review。</li>
<li>否则就列出未推送的变更等待upload。</li>
</ol>
<h2 id="Review路径的获取" class="article-heading"><a href="#Review路径的获取" class="headerlink" title="Review路径的获取"></a>Review路径的获取<a class="article-anchor" href="#Review路径的获取" aria-hidden="true"></a></h2><p>默认情况下Repo要与Gerrit通过两次网络交互才能将变更推送上去，第一个只通过http协议获取一个推送的地址。</p>
<p>Repo会向manifest文件中review属性指定的url发送一个地址为<code>http://$url/ssh_info</code>的http请求，Gerrit会返回提交变更使用的真正ssh地址及端口号。默认的端口号为29418。</p>
<h2 id="推送变更到Gerrit" class="article-heading"><a href="#推送变更到Gerrit" class="headerlink" title="推送变更到Gerrit"></a>推送变更到Gerrit<a class="article-anchor" href="#推送变更到Gerrit" aria-hidden="true"></a></h2><p>Repo使用以下命令格式推送变更：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --receive-pack=<span class="string">'gerrit receive-pack --reviewer=&lt;reviewer_email&gt; --cc=&lt;cc_user_email&gt;'</span> \</span><br><span class="line">         ssh://username@&#123;前面http请求返回的url地址&#125;:&#123;前面返回的端口号&#125;/&lt;project_name&gt; &lt;review_branch&gt;:refs/<span class="keyword">for</span>/&lt;dest_branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>把变更推送到Gerrit后，Repo会更新本地topic分支的<code>refs/published/&lt;branch_name&gt;</code>引用。</p>
<p>其实我们也可以使用手动的方式来推送变更到Gerrit，但是不能自动更新pushlished下的引用，因此再使用<code>repo upload</code>命令时会发现变更会再次让你upload，但其实他们已经推送到Gerrit了，你必须手动更新<code>refs/published/&lt;branch_name&gt;</code>到你的HEAD。</p>

              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2019-04-15T14:12:10.255Z" itemprop="dateModified">上次更新：2019-04-15</time>
                <a href="/2013/08/07/cmake-usage/" class="article-footer-prev" title="cmake学习笔记"><i class="fa fa-chevron-left"></i><span>上一页</span></a>
              </footer>
              
<section id="comments">
  <div id="disqus_thread"></div>
</section>
<script>
  var disqus_shortname = 'antsir';
  var disqus_url = 'https://ant-sir.xyz/20134/02/03/repo-source/index.html';
  var disqus_title = "repo实现学习笔记";
  var disqus_config = function(){
    this.language = 'zh';
  };
  (function(){
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'https://go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">目录</strong>
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO的引导文件"><span class="toc-text">REPO的引导文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#入口"><span class="toc-text">入口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main函数"><span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完整的Repo库"><span class="toc-text">完整的Repo库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用bundle文件"><span class="toc-text">使用bundle文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用代理"><span class="toc-text">使用代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repo仓库地址"><span class="toc-text">Repo仓库地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真正的checkout"><span class="toc-text">真正的checkout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用main-py"><span class="toc-text">调用main.py</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#main-py"><span class="toc-text">main.py</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#导入all-commands"><span class="toc-text">导入all_commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main函数"><span class="toc-text">_Main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Repo类"><span class="toc-text">_Repo类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XmlManifest类"><span class="toc-text">XmlManifest类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MetaProject类"><span class="toc-text">MetaProject类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类的init函数"><span class="toc-text">Project类的init函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程仓库的路径"><span class="toc-text">远程仓库的路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-INIT"><span class="toc-text">REPO INIT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Init类的Execute函数"><span class="toc-text">Init类的Execute函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Init类的-SyncManifest函数"><span class="toc-text">Init类的_SyncManifest函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类图"><span class="toc-text">Project类图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类的Sync-NetworkHalf函数"><span class="toc-text">Project类的Sync_NetworkHalf函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project类的-InitGitDir函数"><span class="toc-text">Project类的_InitGitDir函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplyCloneBundle函数实现"><span class="toc-text">_ApplyCloneBundle函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sync-LocalHalf函数实现"><span class="toc-text">Sync_LocalHalf函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Init类的-LinkManifest函数"><span class="toc-text">Init类的_LinkManifest函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-SYNC"><span class="toc-text">REPO SYNC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sync命令的Execute函数实现"><span class="toc-text">sync命令的Execute函数实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-START"><span class="toc-text">REPO START</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#start命令的Execute函数实现"><span class="toc-text">start命令的Execute函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project类的StartBranch函数"><span class="toc-text">project类的StartBranch函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPO-UPLOAD"><span class="toc-text">REPO UPLOAD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Review路径的获取"><span class="toc-text">Review路径的获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推送变更到Gerrit"><span class="toc-text">推送变更到Gerrit</span></a></li></ol></li></ol>
              <a href="#" id="article-toc-top">回到顶部</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">欢迎</strong><a href="/categories" class="sidebar-link">欢迎</a><strong class="sidebar-title">工具使用</strong><a href="/2013/05/05/learn-git/" class="sidebar-link">Git学习笔记</a><a href="/2019/04/14/use-https/" class="sidebar-link">博客https化历程</a><a href="/2013/07/03/google-repo/" class="sidebar-link">repo工具学习笔记</a><a href="/2013/08/07/cmake-usage/" class="sidebar-link">cmake学习笔记</a><a href="/20134/02/03/repo-source/" class="sidebar-link current">repo实现学习笔记</a><strong class="sidebar-title">学习笔记</strong><a href="/2014/01/07/learn-python/" class="sidebar-link">Python学习笔记</a>
    <strong class="sidebar-title">GIT</strong><a href="/2013/05/05/learn-git/" class="sidebar-link">Git学习笔记</a><strong class="sidebar-title">NGINX</strong><a href="/2019/04/14/use-https/" class="sidebar-link">博客https化历程</a><strong class="sidebar-title">PYTHON</strong><a href="/2014/01/07/learn-python/" class="sidebar-link">Python学习笔记</a><strong class="sidebar-title">REPO</strong><a href="/2013/07/03/google-repo/" class="sidebar-link">repo工具学习笔记</a><a href="/20134/02/03/repo-source/" class="sidebar-link current">repo实现学习笔记</a><strong class="sidebar-title">CMAKE</strong><a href="/2013/08/07/cmake-usage/" class="sidebar-link">cmake学习笔记</a>
 </div>
</aside>

    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2019 <a href="https://ant-sir.xyz" target="_blank">Zhu Yanlei</a><br>
      Documentation licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>.
    </div>
    <div id="footer-links">
      <a href="https://weibo.com/5301170870" class="footer-link" target="_blank"><i class="fa fa-weibo"></i></a>
      <a href="https://github.com/ant-sir/site" class="footer-link" target="_blank"> <i class="fa fa-weixin" aria-hidden="true"></i></a>
      <a href="https://github.com/ant-sir/site" class="footer-link" target="_blank"> <i class="fa fa-qq" aria-hidden="true"></i></a>
      <a href="https://github.com/ant-sir/site" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/" class="mobile-nav-link">主页</a><a href="/categories/" class="mobile-nav-link">分类</a><a href="/archives/" class="mobile-nav-link">归档</a><a href="/about/" class="mobile-nav-link">关于</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/ant-sir/site" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">欢迎</strong><a href="/categories" class="mobile-nav-link">欢迎</a><strong class="mobile-nav-title">工具使用</strong><a href="/2013/05/05/learn-git/" class="mobile-nav-link">Git学习笔记</a><a href="/2019/04/14/use-https/" class="mobile-nav-link">博客https化历程</a><a href="/2013/07/03/google-repo/" class="mobile-nav-link">repo工具学习笔记</a><a href="/2013/08/07/cmake-usage/" class="mobile-nav-link">cmake学习笔记</a><a href="/20134/02/03/repo-source/" class="mobile-nav-link current">repo实现学习笔记</a><strong class="mobile-nav-title">学习笔记</strong><a href="/2014/01/07/learn-python/" class="mobile-nav-link">Python学习笔记</a>
      <strong class="mobile-nav-title">GIT</strong><a href="/2013/05/05/learn-git/" class="mobile-nav-link">Git学习笔记</a><strong class="mobile-nav-title">NGINX</strong><a href="/2019/04/14/use-https/" class="mobile-nav-link">博客https化历程</a><strong class="mobile-nav-title">PYTHON</strong><a href="/2014/01/07/learn-python/" class="mobile-nav-link">Python学习笔记</a><strong class="mobile-nav-title">REPO</strong><a href="/2013/07/03/google-repo/" class="mobile-nav-link">repo工具学习笔记</a><a href="/20134/02/03/repo-source/" class="mobile-nav-link current">repo实现学习笔记</a><strong class="mobile-nav-title">CMAKE</strong><a href="/2013/08/07/cmake-usage/" class="mobile-nav-link">cmake学习笔记</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>简体中文</span></span>
    <select id="mobile-lang-select" data-canonical="">
      
        <option value="zh-cn" selected>简体中文</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- Cookie -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.0/js.cookie.min.js"></script>
<!-- build:js build/js/main.js -->
<script src="/js/lang_select.js"></script>
<script src="/js/toc.js"></script>
<script src="/js/mobile_nav.js"></script>
<!-- endbuild -->
<!-- Algolia -->

<script>document.getElementById('search-input-wrap').classList.add('on');</script>
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script>
  docsearch({
    // Your apiKey and indexName will be given to you once
    // we create your config
    apiKey: '36fb45dc14ef77aa8bdf5b2dbf75c87f',
    indexName: 'hexo-search',
    appId: 'IKDE0Z5WJI', // Should be only included if you are running DocSearch on your own.
    // Replace inputSelector with a CSS selector
    // matching your search input
    inputSelector: '#search-input',
    // Set debug to true if you want to inspect the dropdown
    debug: false,
  });
</script>


</body>
</html>
